/* Copyright(c) 2021 ZiChen Zhang,JiaCheng Pan and all contributors
All right Reserved
    
    Distributed under MIT license
    See copy at https://opensource.org/licenses/MIT
*/
/*
wasd移动，不用说了吧（需要一个回车）
/move + wasd也是移动，如果你设定gamerule.standardized_command参数为1则需要这个命令移动
/set + wasd + 距离 + 方块名称 ==> 在指定方向上的指定距离放置方块
/set d 1 stone即为在右侧放一个石头
/break + wasd + 距离 ==> 在指定方向上的特定距离破坏方块
/break d 1 把刚刚那个石头破坏掉
其他的命令与Minecraft基本上相同，坐标为二维的不要搞错了
*/
/**
 *  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
 *  ┃  OOOOO    /     /   % % %     @   @   ! ! !   #   #   ~ ~ ~ ~  ┃
    ┃ O         /     /   %     %   @   @     !     #   #   ~        ┃
    ┃ O         /     /   %     %   @   @     !     #   #   ~        ┃
    ┃  OOOOO    /     /   % % %     @   @     !     #   #   ~ ~ ~ ~  ┃
    ┃       O   /     /   % %       @   @     !     #   #   ~        ┃
    ┃       O   /     /   %   %       @       !       #     ~        ┃
    ┃ OOOOOO     /////    %     %     @     ! ! !     #     ~ ~ ~ ~  ┃
    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
 * 这里是社区最大的C++版沙盒游戏
 * 从2020/08/26起，我们共计发布了数十个更新，到现在的1.4.2(至2021/07/07)，代码超过2000行，10万字符
 * 在社区成员的帮助下，我们有了许多改进，并不断加入玩家所提议的内容。
 * 
 * 成员表：
 * 主创：ParseY Pasy(张子辰)
 * 代码：ParseY Pasy(张子辰)
 * 美工：ParseY Pasy(张子辰)
 * 测试：ParseY Pasy(张子辰)
 * 剧情：ParseY Pasy(张子辰)
 * 提供帮助：
 *       Rratic（潘嘉诚）      闫雅芮
 *       李梓淇                杨墨轩
 *       尹怀杰                罗昊洋
 * 编译器支持：
 *       学而思编程社区（C站）
 * 发布平台：
 *       学而思编程社区（C站）
 * 版本历史：
 * pre0.0.1（原初版）
 * pre0.0.2
 * pre0.1.0
 * pre0.2.5(重置版本号)
 *     更新内容：初步的地形
 * pre1.1.0(保存)
 * pre1.2.1(保存)
 *     发布时间：2020/10/01 10:50:00
 *     更新内容：实体与地形分离
 * pre1.2.2
 * pre1.2.3(保存)
 *     发布时间：2020/10/01 10:50:00
 *     更新内容：模组，信息栏
 * pre1.2.4（与下面的pre1.2.5.100版本似乎重叠）
 * pre1.2.5.100(保存)
 *     发布时间：2020/11/22 20:45:00
 *     更新内容：成就，语言系统
 * pre1.2.5.200（圣诞版）
 *     发布时间：2020/12/21 21:00:00
 *     更新内容：开始界面
 * 1.1.0 
 * 注：因为前面的版本终止为0.2.x版本，正式版号为1.x.x，所以直接跳过1，2来到1.3.0版本
 * 1.3.1(保存)
 *     发布时间：2021/01/03 23:08:00
 *     更新内容：方块类
 * 1.3.2
 *     更新内容：gamerule指令
 * 21w1a
 *     更新内容：饥饿值，生命值，氧气值
 * 1.3.3
 *     更新内容：生存元素更新
 * 1.3.4(保存)
 *     发布时间：2021/01/28 16:30:00
 *     更新内容：命令组
 * 1.3.5(保存)
 *     发布时间：2021/02/08 21:30:00
 *     更新内容：区块
 * 1.4.1(保存)
 *     发布时间：2021/05/02 17:00:00
 *     更新内容：真正的地形
 * 1.4.2(保存)
 *     发布时间：2021/06/18
 *     更新内容：无限世界
 * 1.4.2.2(保存)
 *     发布时间：2021/07/25
 *     更新内容：bug消除+存档功能
 * 1.4.3
 *     定档时间：2021/07/31
 *     更新内容：UI,Unicode
 > 1.5.0（计划）
 >     定档时间：2021/08/26
 >     更新内容：维度
 *Survive一周年庆典！
 * 现代码量：2509行
 **/
#include <iostream>
#include <time.h>
#include <cstdlib>
#include <bits/stdc++.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <stack>
#include <stdio.h> 
#define DefaultUpdate Default();
#ifndef __linux
	#define clear system("cls");
#endif
#ifdef __linux
	#define clear system("clear");
#endif //一键适配,来自潘嘉诚
#define ll long long
#define red "\033[41m"//红
#define ce  "\033[m"//清除效果
#define lime "\033[42m"//绿
#define yel  "\033[43m";//黄
#define bl   "\033[44m";//蓝
using namespace std;
//看什么看，这玩意迟早要删
const ll WorldYSize = 256;//世界的纵向最大距离
//系统函数若不符合任何条件时，会原地更新一次，保证任何操作都能更新玩家数据
const string GameLatestVersion = "Survive 1.4.2.2";//游戏名称及最新版本
const ll MAX_INT = 9223372036854775807;
const ll PRINT_SPEED = 32134;
const ll block_num = 16;
const ll achievement_num = 6;
const ll gamemode_num = 2;
const ll biome_num = 11;
const ll chunk_total = MAX_INT / 16 + 1;
const ll gamerule_num = 10;
const ll command_num = 27;
const ll maxItemNum = 16384;
const ll no_damage = -2147483647;
const ll positive_crash_line = 9223372036854775791;
const ll negative_crash_line = -15;
ll player_oxygen;
ll respawnx = 1024,respawny = 192,playerx,playery = WorldYSize / 2,lang,sea_level  = WorldYSize - WorldYSize / 4,vision_size = 16,boarder_x = MAX_INT,boarder_y = WorldYSize,game_time;//从左到右依次为重生x坐标及y坐标，玩家的实时x与y坐标，方块数量boarder_x = WorldXSize,boarder_y = WorldYSize;
ll world_sx = 0,world_ex = MAX_INT - 1,world_sy = 0,world_ey = WorldYSize - 1,maxinum_fill = 16384;
ll chunk_now = playerx / 16;
ll block_ID[]      = {0,1,2,3,4,5,6,7,8,9,10,11,12};
ll block_hardness[] = {10,10,5,5,-2147483647,-1,-1,-1,-2147483647,7,10,10,5,2};
ll block_explosion_resistance[] = {30,30,3,3,2147483647,0,500,500,2147483647,10,17,12,1,0};
ll biome_tree_density[] = {10,0,0,0,0,0,0,50,75,0};//树木密度
ll biome_tree_maxsize[] = {3,0,0,0,0,0,0,4,32,0};//最大树木高度
ll biome_surface_block[] = {2,12,0,0,6,7,1,2,2,1,0};//生物群系的地表方块
ll biome_sealevel[] = {-15,-25,-50,-100,25,25,-10,-15,-15,-150,0};
ll mod_total,mod_block_total,mod_item_total,mod_command_total;
ll item_maxstacknum[] = {64,64,64,64,64,64,64,64,64,64,64,64,64};//物品的最大堆叠数量
ll gamefile_item_num = 0,gamefile_UI_num = 0;
ll   item_damage[] = {no_damage,no_damage,no_damage,no_damage,no_damage,no_damage,no_damage,no_damage,no_damage,no_damage,no_damage,no_damage,no_damage};//物品耐久（-2147483647代表无耐久）
ll filesize = 0;
double player_heart,player_hunger,player_full;
long long seed;
char default_block_char = '?';
char block_char[]   = {'O','@','+','%','/',' ','~','-','&','|','F','C','$','^','?','#'};
//从左到右：石头，圆石，泥土（也可以是草方块），屏障，空气，水，岩浆，基岩，树木，熔炉，工作台，沙子，树叶
char entity_showchar[] = {' ','!'};
string texture_block[] = {"石","圆","草","泥","障","  ","水","浆","基","木","炉","台","沙","叶","煤"};//材质包，发挥艺术天分吧！
string texture_entity[] = {"  ","玩"};
char item_char[] = {' ','@','+','%','/','|','|','X','=','=','=','#','$'};//物品的符号(几乎用光了所有字符)
char mod_block_char[128],mod_item_char[128];//用于存放模组定义的新方块及物品
string language,gamemode = "survival",active_screen,warningtext,worldname,playername,filename,file_savetime;
string language_name[] = {"中文","中文繁體","English"};
string tag_type[] = {"unbreakable","lleraction","plant","ore_replaceable","through","gravity","oxygen","fluid"};//标签类型
string block_name[] = {"stone","cobblestone","grass","dirt","barrier","air","water","lava","bedrock","wood","furnace","crafting_table","sand","leave","unknown_block","coal_ore"};
string block_color[] = {"\033[48;2;192;192;192m","\033[48;2;128;128;128m","\033[48;2;128;255;0m","\033[48;2;96;32;48m","\033[48;2;128;64;192m","\033[48;2;0;255;255m","\033[48;2;0;128;255m","\033[48;2;255;96;0m","\033[48;2;64;64;64m","\033[48;2;128;128;16m","\033[48;2;192;192;160m","\033[48;2;192;160;64m","\033[48;2;240;240;128m","\033[48;2;64;192;32m","\033[48;2;0;0;0m","\033[48;2;128;128;96m"};
string item_name[]={"VOID","stone","cobblestone","grass","dirt",
                    "barrier","water","lava","bedrock",
                    "wood","furnace","crafting_table","sand","coal_ore",
                    "stick","leave","wood plank"
};
string UI_place[] = {"backpack","simplecraft","crafting table","furnace","chest"};
string gamemode_name[] = {"survival","creative"};
string biome_name[] = {"plain","desert","mountain","extreme mountain","ocean","lava sea","stone plain","forest","jungle","vocano","extreme_plain"};
string achievement_name[] = {"Move!","First block set!","First block break!","Too hard!","Welcome to the void","I'm stuck!","Changeable World"};//成就名称
string mod_list[99],mod_command_list[99],mod_block_name[99],mod_item_name[99];//99个模组及新命令,方块，物品......够用了吧
string gamerule_list[] = {"color","vision_size","boarder_size","standardized_command","maxinum_fill","player_name","world_name","auto_jump","respawn_point","load_texture"};
string gamerule_parameter[] = {"b","i","ii","b","i","s","s","b","ii","b",};//格式化的参数类型
string command_name[] = {"w","a","s","d","/move","/set","/break","/fill","/tp","/clone","/gamemode","/help","/open","/gamerule","/testblock","/kill","/eat","/setblock","/seed","/biome","/say","/lang","/give","/throw","/savefile"};//命令名称
string command_parameter[] = {"n","n","n","n","c","cis","ci","long","long","long","s","n","s","long","ci","n","n","iis","n","n","long","s","si","i","s"};//命令所需参数
bool skip,achievement_get[5] = {0},color_on = 0,standardized_command = 0,auto_jump = 1,texture_loaded = 0;//跳过开场判断及用于成就的布尔数组
bool item_istool[] = {0,0};//物品是否为工具
bool item_isfood[] = {0,0,0,0,0,0,0,0,0,0,0,0,0};//物品是否为食物
stack <string> info_text;//信息栈，在运行中持续累加再在信息栏中输出
stack <string> info_chat;//聊天信息列表
char screen[18][18] = {{'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#'},
                       {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'}
};
ll crafting_formula[24][3][3] = {   
                                {
                                    {0,0,0},
                                    {0,7,0},
                                    {0,7,0}
                                },//合成：木棍
                                {
                                    {7,7,7},
                                    {0,6,0},
                                    {0,6,0}
                                },//合成：木镐
                                {
                                    {1,1,1},
                                    {0,6,0},
                                    {0,6,0}
                                },//合成：石镐
                                {
                                    {8,8,8},
                                    {0,6,0},
                                    {0,6,0}
                                },//合成：铁镐
                                {
                                    {9,9,9},
                                    {0,6,0},
                                    {0,6,0}
                                },//合成：金镐
                                {
                                    {10,10,10},
                                    {0,6,0},
                                    {0,6,0}
                                },//合成：钻石镐
                                {
                                    {11,11,11},
                                    {0,6,0},
                                    {0,6,0}
                                },//合成：绿宝石镐(当前最快最坚硬的镐)
                                {
                                    {0,2,0},
                                    {0,2,0},
                                    {0,6,0}
                                },
                                {
                                    {0,7,0},
                                    {0,7,0},
                                    {0,6,0}
                                },//合成：木剑
                                {
                                    {0,1,0},
                                    {0,1,0},
                                    {0,6,0}
                                },//合成：石剑
                                {
                                    {0,8,0},
                                    {0,8,0},
                                    {0,6,0}
                                },//合成：铁剑
                                {
                                    {0,9,0},
                                    {0,9,0},
                                    {0,6,0}
                                },//合成：金剑
                                {
                                    {0,10,0},
                                    {0,10,0},
                                    {0,6,0}
                                },//合成：钻石剑
                                {
                                    {0,11,0},
                                    {0,11,0},
                                    {0,6,0}
                                },//合成：绿宝石剑(伤害最高的剑)
                                {
                                    {0,2,0},
                                    {0,2,0},
                                    {0,6,0}
                                },
                                {
                                    {0,7,0},
                                    {0,7,0},
                                    {0,6,0}
                                },//合成：木剑
                                {
                                    {1,1,0},
                                    {1,6,0},
                                    {0,6,0}
                                },//合成：石斧
                                {
                                    {8,8,0},
                                    {8,6,0},
                                    {0,6,0}
                                },//合成：铁斧
                                {
                                    {9,9,0},
                                    {9,6,0},
                                    {0,6,0}
                                },//合成：金斧
                                {
                                    {10,10,0},
                                    {10,6,0},
                                    {0,6,0}
                                },//合成：钻石斧
                                {
                                    {11,11,0},
                                    {11,6,0},
                                    {0,6,0}
                                },//合成：绿宝石斧(速度最快，耐久最高的斧)
                                {
                                    {1,1,1},
                                    {1,0,1},
                                    {1,1,1}
                                },//合成：熔炉
                                {
                                    {7,7,0},
                                    {7,7,0},
                                    {0,0,0}
                                },//合成：工作台
                                {
                                    {7,7,7},
                                    {7,0,7},
                                    {7,7,7}
                                }//合成：箱子
};//以三维数组存储的合成公式,可随意编辑
//上面水了150行
ll mod_crafting_formula[128][3][3];
char TitleScreen[7][31] = {{' ','O','O','O',' ','/',' ',' ','/',' ','%','%','%',' ',' ','@',' ','@',' ','!','!','!',' ','#',' ','#',' ','~','~','~','~'},
                           {'O',' ',' ',' ',' ','/',' ',' ','/',' ','%',' ',' ','%',' ','@',' ','@',' ',' ','!',' ',' ','#',' ','#',' ','~',' ',' ',' '},
                           {'O',' ',' ',' ',' ','/',' ',' ','/',' ','%',' ',' ','%',' ','@',' ','@',' ',' ','!',' ',' ','#',' ','#',' ','~',' ',' ',' '},
                           {' ','O','O','O',' ','/',' ',' ','/',' ','%','%','%',' ',' ','@',' ','@',' ',' ','!',' ',' ','#',' ','#',' ','~','~','~','~'},
                           {' ',' ',' ',' ',' ','/',' ',' ','/',' ','%','%',' ',' ',' ','@',' ','@',' ',' ','!',' ',' ','#',' ','#',' ','~',' ',' ',' '},
                           {' ',' ',' ','O',' ','/',' ',' ','/',' ','%',' ','%',' ',' ',' ','@',' ',' ',' ','!',' ',' ',' ','#',' ',' ','~',' ',' ',' '},
                           {'O','O','O',' ',' ',' ','/','/',' ',' ','%',' ',' ','%',' ',' ','@',' ',' ','!','!','!',' ',' ','#',' ',' ','~','~','~','~'}};
//超级资源包
string language_achievement[] = {"成就达成! - ","成就達成! -","Achievement got! - ","移动！","移動！","Move!","放置方块！","放置方塊！","First block set!","破坏方块！","破壞方塊！","First block break!","为什么这么硬！","爲什麼這麼硬！","Too hard!","欢迎来到虚空","歡迎來到虛空","Welcome to the void","卡住了！","卡住了！","I'm stuck!","多变的世界","多變的世界","Changeable World"};//成就语言包
string language_briefinfo[] = {"坐标","坐標","Position","游戏模式","遊戲模式","Gamemode","输入/help以获取帮助","輸入/help以獲取幫助","Prll /help for help"};//简略信息语言包
string language_celebrate[] = {"新年快乐！","新年快樂！","Happy New Year!"};//节日庆祝语言包
string language_clone[] = {"克隆位置在世界之外，检查(","克隆位置在世界之外，檢查(","Clone Position out of world,Check at (","成功克隆区内方块(","成功克隆區內方塊(","Successfully clone blocks in area (",")由(",")由(",") to area starts from("};//clone指令语言包
string language_Command[] = {"#命令 -->","#命令 -->","#Command -->"};//命令行语言包
string language_fill[] = {"成功填充了","成功填充了","Successfully filled ","方块","方塊","blocks","无法填满世界以外的方块(","無法填滿世界以外的方塊(","Impossible to fill blocks outside the world at (","方块总数太多(","方塊總數太多(","Total number of blocks is too much("};//fill指令语言包
string language_gamerule[] = {"的值被成功改为","的值被成功改爲"," has successfully been changed to ","缺失参数，请检查输入","缺失參數，請檢查輸入","Missing parameter,please check the input"};
string language_help1[] = {"1.简介","1.簡介","1,Biref llroduction","2.命令","2.命令","2.Command","3.版本信息","3.版本信息","3.Version Information","4.模组","4.模組","4.Mods","选择(1 - 4),输入-1退出","選擇(1-4),輸入-1退出","Choose(1-4),prll -1 to exit"};//help主界面
string language_help2[] = {"选择跳转界面(退出为0) -->","選擇跳轉界面(退出為0) -->","Choose the llerface to skip(0 for exit) -->"};//help选择语言包
string language_help3[] = {"游戏名：Survive\n最新版本：","遊戲名：Survive\n最新版本：","Game Name: Survive\nLatest Version:","这个游戏基于C++编写，是目前社区内最大的C++沙盒游戏，玩家能在游戏里自由的放置破坏方块，并使用各种指令","這個遊戲基於C++編寫，是目前社區內最大的C++沙盒遊戲，玩家能在遊戲裏自由的放置破壞方塊，並使用各種指令","This game is based on C++, is currently the community's largest C++ sandbox game, players can freely place in the game destroy blocks, and use various instructions","游戏完全开源，其他人可自由编写模组，或报告漏洞,bug,撰写新功能甚至同人版本，一切仅限于玩家的想象力","遊戲完全開源，其他人可自由編寫模組，或報告漏洞,bug,撰寫新功能甚至同人版本，一切僅限於玩家的想象力","The game is completely open source, allowing others to write modules, report bugs, write new features or even clone versions, all within the player's imagination"};//简介语言包
string language_help4[] = {"1.基本命令","1.基本命令","1.Basic command","2.创造命令","2.創造命令","2.Creative command","3.通配符","3.通配符","3.wildcard"};//help-命令语言包
string language_help5[] = {"基本命令包括/move,/set,/break,wasd,/open,/gamemode, 是玩家必须掌握的基本操作","基本命令包括/move,/set,/break,wasd,/open,/gamemode, 是玩家必須掌握的基本操作","Basic commands include/move/set, / break, wasd, / open/gamemode, players must master the basic operation",
                               "1.移动","1.移動","1.Moving",
                               "在命令行里输入w(上),a(左),s(下),d(右)可以让玩家向对应方向前进一格，但如果前进方向上有实体方块则不会执行","在命令行裏輸入w(上),a(左),s(下),d(右)可以讓玩家向對應方向前進一格，但如果前進方向上有實體方塊則不會執行","Typing w(up), a (left), s (down),d(right) on the command line allows the player to move one block in that direction, but not if there is a solid block in that direction",
                               "移动指令的另一种写法是/move + 方向参数，其中方向参数也为wasd,是指令的标准化写法，但与单参数控制效果相同","移動指令的另一種寫法是/move + 方向參數，其中方向參數也爲wasd,是指令的標準化寫法，但與單參數控制效果相同","Another way of writing the move instruction is /move + direction parameter, where the direction parameter is also wasd, which is the standardized writing of the instruction, but has the same effect as the single-parameter control",
                               "2.放置与破坏方块","2.放置與破壞方塊","2. Place and break the block",
                               "使用/set指令可以放置方块，格式为/set + 方向参数 + 放置距离 + 方块名称或ID","使用/set指令可以放置方塊，格式爲/set + 方向參數 + 放置距離 + 方塊名稱或ID","Blocks can be placed using the command /set in the format/Set + orientation parameter + place distance + block name or ID",
                               "使用/break指令可以破坏方块，格式为/break + 方向参数 + 破坏距离","使用/break指令可以破壞方塊，格式爲/break + 方向參數 + 破壞距離","Using the /break command, blocks can be broken in the form of /break + direction parameter + break distance",
                               "方向参数为w,a,s,d,放置方块名称可以为其ID号，比如 /set w 1 stone 与/set w 1 0 效果一样（stone的ID为0）","方向參數爲w,a,s,d,放置方塊名稱可以爲其ID號，比如 /set w 1 stone 與/set w 1 0 效果一樣（stone的ID爲0）","The orientation parameters are w, a, s, d, and the placed block name can be its ID number. For example, /set w 1 stone has the same effect as /set w 1 0 (the ID of the stone is 0).",
                               "需要注意是，break指令并不能破坏边界屏障，无论是否更新（break命令设定无法破坏屏障，即使破坏，屏幕更新后也会被修补）","需要注意的是，break指令並不能破壞邊界屏障，無論是否更新（break命令設定無法破壞屏障，即使破壞，屏幕更新後也會被修補）","It should be noted that the break command does not break the border barrier, whether or not it is updated (the break command setting does not break the barrier, and even if it is broken, the screen will be repaired after update)."
                               "3.gamemode指令","3.gamemode指令","3. The gamemode command",
                               "gamemode指令能改变玩家游戏模式","gamemode指令能改變玩家遊戲模式","The gamemode command can change the player's gamemode",
                               "格式/gamemode + 模式参数","格式/gamemode + 模式參數","Format/Gamemode + mode parameters",
                               "其中模式可填survival(生存)或creative(创造),也可以填模式ID（生存-0，创造-1）","其中模式可填survival(生存)或creative(創造),也可以填模式ID（生存-0，創造-1）","The mode can be filled with survival or creative, or with the mode ID (survive-0, creation-1).",
                               "4./open指令","4./open指令","4. /open command",
                               "格式 /open + 界面参数","格式 /open + 界面參數","Format/Open + llerface parameters",
                               "界面可填 backpack（背包）,info(开发者信息)","界面可填 backpack（揹包）,info(開發者信息)","界面可填 backpack（揹包）,info(開發者信息)",
                                "5./gamerule指令","5./gamerule指令","5./gamerule command",
                                "","","",            
};//help-基本命令语言包
string language_help6[] = {"创造命令包括/tp,/fill,这些命令只能在创造模式下使用\n 1./tp指令\n /tp能将玩家传送至任意位置，无论其所在位置是否有实体方块，格式为/tp 传送坐标x 传送坐标y \n 需要注意的是玩家在传送后很有可能卡在方块里，当周围有方块时，玩家便无法进行移动，此时只能破坏方块或再次传送\n 2./fill指令\n /fill指令能将特定区域的所有方块替换为同一类型的方块，格式为/fill 开始坐标x 开始坐标y 结束坐标x 结束坐标y 方块参数\n其中四个坐标可为世界绝对坐标或玩家局部坐标，方块参数可为ID或名称\n上述两个命令均可适用通配符","創造命令包括/tp,/fill,這些命令只能在創造模式下使用\n 1./tp指令\n /tp能將玩家傳送至任意位置，無論其所在位置是否有實體方塊，格式爲/tp 傳送座標x 傳送座標y /n需要注意的是玩家在傳送後很有可能卡在方塊裏，當週圍有方塊時，玩家便無法進行移動，此時只能破壞方塊或再次傳送\n 2./fill指令\n /fill指令能將特定區域的所有方塊替換爲同一類型的方塊，格式爲/fill 開始座標x 開始座標y 結束座標x 結束座標y 方塊參數\n其中四個座標可爲世界絕對座標或玩家局部座標，方塊參數可爲ID或名稱\n上述兩個命令均可適用通配符","Create commands include /tp /fill, these commands can only be used in creative mode\n 1.Command /tp \n /tp players can be transported to any position,regardless of its location block is or not air,format for transport command is /tp send coordinates x coordinate y \n need to pay attention to the players after the transport is likely to be stuck in a block, when surrounded by blocks, players can't be moved, at this time can only destroy blocks or again transport. \n 2. /fill Command \n /fill a particular area of all blocks can be replaced for the same type of blocks,The format is /fill <start coordinate x> <start coordinate y> <end coordinate x> <end coordinate y> <block parameter> \n where the four coordinates can be world absolute coordinates or player local coordinates and the block parameter can be ID or name\n the above two commands are applicable to wildcards"};//help-创造指令语言包
string language_help7[] = {"通配符(~)是用于将绝对坐标转换为局部坐标的命令符\n其中世界绝对坐标指方块在世界数组中所对的x,y下标\n而局部坐标则是在绝对坐标基础上加上玩家坐标\n 在数字前面加上通配符,则这个数字会被游戏认定为相对于玩家的坐标\n /tp 及 /fill指令可使用通配符，目前也仅有这两个命令需要坐标参与","通配符(~)是用於將絕對座標轉換爲局部座標的命令符\n其中世界絕對座標指方塊在世界數組中所對的x,y下標\n而局部座標則是在絕對座標基礎上加上玩家座標\n 在數字前面加上通配符,則這個數字會被遊戲認定爲相對於玩家的座標\n /tp 及 /fill指令可使用通配符，目前也僅有這兩個命令需要座標參與","Wildcards (~) is used to command of absolute coordinates can be converted llo the local coordinate system operator\n which the absolute coordinates mean square in the world in an array of x, y /n subscript and local coordinates is based on the absolute coordinates plus player coordinates/n in front of the Numbers and wildcard, this number will be identified as coordinates relative to the player's game/n /tp and/fill instruction can use wildcards, at present, only the two commands need to coordinate"};//help-通配符语言包
string language_help8[] = {"Indev及更早的版本(未保存)","Indev及更早的版本(未保存)","Indev and earlier versions (not saved)",
"Indev0.0.1  最早的版本，加入了玩家，地图，移动","Indev0.0.1 最早的版本，加入了玩家，地圖，移動","The earliest version of Indev0.0.1 adds players, maps, and movement",
"0.1.0  加入了放置与破坏方块","0.1.0 加入了放置與破壞方塊","0.1.0 added placement and destruction squares",
"pre0.1.1  加入了方块的名称及ID，改进了放置与破坏方块指令","pre0.1.1 加入了方塊的名稱及ID，改進了放置與破壞方塊指令","Pre0.1.1 includes the name and ID of the block, improving the placing and breaking of the block instructions",
"0.1.1正式版  加入了世界边界，拓宽了世界大小","1.0.0正式版 對底層代碼的大量改進，遊戲更名爲Survive","The official version adds world boundaries and broadens the world's size",
"1.0.0正式版  对底层代码的大量改进，游戏更名为Survive","1.0.0正式版 對底層代碼的大量改進，遊戲更名爲Survive","The 1.0.0 official release features a number of improvements to the underlying code, and the game is renamed Survive",
"pre1.1.1  加入了/tp /fill指令","pre1.1.1 加入了/tp /fill指令","Pre1.1.1 includes the/tp,/fill command",
"pre1.1.2  完善了Command函数，加入了通配符~","pre1.1.2 完善了Command函數，加入了通配符~","Pre1.1.2 perfects the Command function with the addition of wildcards ~",
"pre1.1.3  UI加入，加入了/open指令","pre1.1.3 UI加入，加入了/open指令","Pre1.1.3 UI added and added /open instruction",
"pre1.1.4  加入了更好的地形（极 其 诡 异），并加入了背包，工作台，熔炉的UI及相关命令","pre1.1.4 加入了更好的地形（極 其 詭 異），並加入了揹包，工作臺，熔爐的UI及相關命令","Pre1.1.4 adds better terrain (which is very strange) and adds the UI for knapsack, workbench, furnace and related commands",
"1.1.0正式版  对于所有代码进行了格式统一，删除了大量无用空行或函数,同时修复了一些bug","1.1.0正式版 對於所有代碼進行了格式統一，刪除了大量無用空行或函數,同時修復了一些bug","The 1.1.0 version unifies the format of all the code, removes a large number of useless blank lines or functions, and fixes some bugs",
"pre1.2.1  加入了实体层，地形层，分离了方块与实体，同时对地形进行了优化","pre1.2.1 加入了實體層，地形層，分離了方塊與實體，同時對地形進行了優化","Pre1.2.1 added the solid layer and terrain layer, separated the blocks and entities, and optimized the terrain at the same time",
"pre1.2.2  删除了pre1.2.1关于地形的更新，加入了初步模组兼容,加入了一系列常量，世界可以调整大小","pre1.2.2 刪除了pre1.2.1關於地形的更新，加入了初步模組兼容,加入了一系列常量，世界可以調整大小","Pre1.2.2 removes the pre1.2.1 terrain update, adds preliminary module compatibility, and adds a series of constants so the world can be resized",
"pre1.2.3  最重大的更新，加入了模组的兼容与使用，信息界面，教程，并再次修订代码，删除大量无用或重复语句，有效代码量首次突破1000行","pre1.2.3 最重大的更新，加入了模組的兼容與使用，信息界面，教程，並再次修訂代碼，刪除大量無用或重複語句，有效代碼量首次突破1000行","The most significant update added module compatibility and use, information llerface, tutorial, and revised the code again, removing a large number of useless or repetitive statements, effective code volume exceeded 1000 lines for the first time",
"pre1.2.4  加入了/clone指令，成就系统加入，修复了部分UI","pre1.2.4 加入了/clone指令，成就係統加入，修復了部分UI","Pre1.2.4 added /clone instruction to join the system and repaired part of the UI",
"1.3.0  新年更新，对所有代码进行了修订","1.3.0 新年更新，對所有代碼進行了修訂","New Year's update 1.3.0, all the code has been revised",
"1.3.1  重大更新，加入了方块类，世界基本单位形成","1.3.1 重大更新，加入了方塊類，世界基本單位形成","1.3.1 major update, the addition of the block class, the world base unit formation",
"1.3.2  加入了/gamerule指令,是目前最大的功能","1.3.2 加入了/gamerule指令,是目前最大的功能","1.3.2 has added the /gamerule directive, which is by far the biggest feature",
"21w1a快照  加入了玩家的生命值，饥饿值，氧气值","21w1a快照 加入了玩家的生命值，飢餓值，氧氣值","21w1a snapshot  Add health, hunger, and oxygen to the player",
//"1.3.3  加入了更多生存元素，并修复了一系列bug，尝试加入地形","","",
"#现在版本：","#現在版本：","#Now Version:"};//版本信息语言包
string language_initilize[] = {"输入世界的名称 -->","輸入世界的名稱 -->","Please prll World's name -->","输入玩家的名称 -->","輸入玩家的名稱 -->","Please prll player's name","您好，","您好，","Hello,","在这个世界生存下去！","在這個世界生存下去！","Survive in this world!","世界加载中-","世界加載中-","Loading World-"};//初始化语言包
string language_kill[] = {"失败了","失敗了"," failed","饿的眼前一黑","餓的眼前一黑"," died of hunger","溺水了","溺水了"," was drowned"};
string language_player[] = {"氧气值：","氧氣值：","Oxygen: "};
string language_prllinfo[] = {"系统: ","系統: ","System: "};//系統提示语言包
string language_set[] = {"未知方块:","未知方塊:","Unknown block:"};//setblock语言包
string language_setblock[] = {"无法在世界外放置方块","無法在世界外放置方塊","Unable to set a block outside the world","无法找到指定方块","無法找到指定方塊","Unable to find the specified block"};
string language_testblock[] = {"未知方向：","未知方向：","Unknown Direction:","无法检测世界外的方块","無法檢測世界外的方塊","Unavailable to check the block outside the world","成功探测！方块名称：","成功探測！方塊名稱：","Successfully detected ! Block name: "};//testblock语言包
string language_TitleScreen[] = {"1P工作室出品","1P工作室出品","Made by 1P Studio(One Person studio)","最后更新时间:","最後更新時間:","Latest Update Time:","现在版本：","現在版本：","Version Now:","制作人员：张子辰，潘嘉诚","製作人員：張子辰，潘嘉誠","Producer List: Pasli Zhang, JiaCheng Pan","跳过开场？是按1，否按0:","跳過開場？是按1，否按0:","Skip the begining or not? 1 for yes, 0 for no:","快捷模式(0/1) -->","快捷模式(0/1) -->","Quick Mode(0/1) -->","建议窗口宽度","建議窗口寬度","Recommended window width:"};//标题语言包
string language_tp[] = {"不可能在世界之外传送实体(位置x =","不可能在世界之外傳送實體(位置x =","Impossible to transport entity outside the world(position x = ","成功传送玩家到位置x =","成功傳送玩家到位置x =","Successfully transport player to position x = "};//tp指令语言包
string language_UIP[] = {"#坐标 x:","#座標 x:","#Position x:","#游戏模式：","#遊戲模式：","#Gamemode: ","#游戏版本：","#遊戲版本：","#Game Veision: ","#世界大小：","#世界大小：","#World Size: ","方块","方塊","blocks","#所观察的坐标 开始(","#所觀察的座標 開始(","#View Position Start(",",),结束(","),結束(","),End(","#世界名称：","#世界名稱：","#World Name:","#玩家名称：","#玩家名稱：","#Player Name: "};//调试信息语言包
string language_UIPmods[] = {"#模组信息:","#模組信息:","#Mod Information:","#模组列表:","#模組列表:","#Mod List:","#模组命令列表：","#模組命令列表：","#Mod Command List:","#模组方块列表：","#模組方塊列表：","#Mod blocks list:","#模组物品列表：","#模組物品列表：","#Mod Item List：","个模组加载","個模組加載"," mods loaded"};//mod调试信息语言包
string language_warncommand[] = {"未定义的游戏模式: ","未定義的遊戲模式: ","Undecleared Gamemode:","未知命令：","未知命令：","Unknown Command: "};

struct Block{
    short ID;//编号
    ll hardness;//硬度
    ll explosion_resistance;//爆炸抗性
    char show_char;//显示字符
    string name;//名称
    short type;//类型
    string tag;//标签
}Block_List[16];
ll topox(ll x){
    return x - (x/16)*16;
}//全局坐标转区块坐标
ll index(ll x,ll y){
    return (WorldYSize-y)*16+x;
}//方块在区块内坐标
class Chunk{
    public:
        ll ID;
        short terrain[WorldYSize*16],entity[WorldYSize*16];
        bool active;
        bool discovered;
    public:
        ll GetBlockInfo(ll x,ll y){
            return terrain[index(topox(x),y)];
        }                   
        ll GetEntityInfo(ll x,ll y){
            return entity[index(topox(x),y)];
        }
};
vector<Chunk> world_chunk;//动态世界数组
ll gcID(ll iID){
    for(ll gId = 0;gId < world_chunk.size();gId++){
        if(world_chunk[gId].ID==iID)
            return gId;
    }
    return -1;
}//获取实际ID在世界数组内的位置
bool incvect(ll iID){
    if(!world_chunk.empty()){
        for(ll inv = 0;inv < world_chunk.size();inv++){
            if(world_chunk[inv].ID==iID)
                return 1;
        }
    }
    return 0;
}//判断指定区块ID是否在世界数组内
class ImprovedNoise{
    public :
    	ImprovedNoise()
    	{
    		ll permutation[512] ={ 151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,
    		                        225,140,36,103,30,69,142,8,99,37,240,21,10,23,
                                    190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
                                    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
                                    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
                                    102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,
                                    135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,
                                    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
                                    223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,
                                    129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,
                                    251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,
                                    49,192,214,31,181,199,106,157,184, 84,204,176,115,121,50,45,127,4,150,254,
                                    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180};
    		for (ll i = 0;i<256;i++)
    		    p[256 + i] = p[i] = permutation[i];
    	}
    	double noise(double x, double y, double z) {
    		ll X = (ll)floor(x) & 255,Y = (ll)floor(y) & 255,Z = (ll)floor(z) & 255;
    			x -=floor(x);                            
    			y -=floor(y);                            
    			z -=floor(z);
    		double  u = fade(x),v = fade(y),w = fade(z);
    		ll A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z,
    		    B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z; 
            return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),
    							           grad(p[BA], x - 1, y, z)), 
    					           lerp(u,grad(p[AB], x, y - 1, z),  
    								    grad(p[BB], x - 1, y - 1, z))),
    			            lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1), 
    							 grad(p[BA + 1], x - 1, y, z - 1)), 
    				    lerp(u, grad(p[AB + 1], x, y - 1, z - 1),
    						 grad(p[BB + 1], x - 1, y - 1, z - 1))));
    	}
    	double fade(double t){
    	    return t * t * t * (t * (t * 6 - 15) + 10);
    	}
    	double lerp(double t, double a, double b){
    	    return a + t * (b - a);
    	}
    	double grad(ll hash, double x, double y, double z){
    		ll h = hash & 15;                     
    		double u = h < 8 ? x : y,
    		       v = h < 4 ? y : h == 12 || h == 14 ? x : z;
    		return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
    	}
    	ll p[512];
}TerrainNoise;
/*————————————————
版权声明：本文为CSDN博主「旅程TSH」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u010669231/article/details/97051705*/
//感谢CSDN的噪声算法！
//函数CC,EV,ITP,ICS,LC,SCI,PI,BI,MBI,MCI,GI,CRM均为系统处理函数
void Default(){
    world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),playery)] = 1;
}//默认更新
bool CompareChart(ll a[3][3],ll b[3][3]){
    for(ll CCx = 0;CCx<= 2;CCx++){
        for(ll CCy = 0;CCy <= 2;CCy++){
            if(a[CCy][CCx] != b[CCy][CCx])
                return 0;
        }
    }
    return 1;
}//用于比较合成公式
long long ExactValue(long long input){
    if(input > 0)
        return input;
    else
        return -1 * input;
}//求整数的绝对值
void p(string input){
    auto input_length_ITP = input.length() - 1;
    for(ll i = 0;i<= input_length_ITP;i++){
        printf("%c",input[i]);
        usleep(PRINT_SPEED);//取自潘某人的阅读速度调查，将标准速度定为32134，大约一秒3个字
    }
    cout << endl;
}
string itos(ll input){
    string out_itos;
    ll input_cpy = input;
    do{
        out_itos=char('0' + int(abs(input%10)))+out_itos;
        input/=10;
    }while(input);
    if(input_cpy<0)
        out_itos='-'+out_itos;
    return out_itos;
}    
ll strtoi(string input){
    ll output_SCI = 0;
    ll input_length_SCI = input.length() - 1;
    for(ll i = 0;i<= input_length_SCI;i++){
        if(input[i] >= '0' && input[i] <= '9'){
            output_SCI *= 10;
            output_SCI += (input[i]- 48);
        }
    }
    for(ll j = 0;j<= input_length_SCI;j++)
    {
        if(input[j] == '-'){
            output_SCI *= -1;
            break;
        }
    }//无论负号在哪里，都认为是负数
    return output_SCI;
}//将字符串转为整型数字
double strtof(string input){
    int si_stof = 0;
    double output_stof = 0.0;
    while(input[si_stof]!='-'&&!isdigit(input[si_stof])&&si_stof<input.length())
        si_stof++;
    bool neg_flag = 0;
    while(input[si_stof]!='.'){
        if(input[si_stof]!='-'){
            output_stof*=10;
            output_stof += (input[si_stof]-'0');
        }else
            neg_flag = 1;
        si_stof++;
    }
    double fpart = 0.1;
    si_stof++;
    while(si_stof<input.length()){
        output_stof+=(input[si_stof++]-'0')*fpart;
        fpart/=10.0;
    }
    if(neg_flag)
        output_stof *= -1;
    return output_stof;
}
string cpystr(string input,int rept){
    for(int ics = 0;ics<rept;ics++)
        input+=input;
    return input;
}
string to_str(char a){
    string atos;
    atos+=a;
    return atos;
}
string getTime(){
    time_t nowt = time(0); 
    char tmp[20]; 
    strftime(tmp, sizeof(tmp), "%Y/%m/%d %X",localtime(&nowt)); 
    string outT = tmp;
    return outT;
}
int half_precision(double input){
    return (abs(input-floor(input)) < abs(ceil(input)-input))?int(floor(input)):int(ceil(input));
}
char Lower_Char(char input){
	if(input >= 'A' && input <= 'Z')
        input += 32;
    return input;
}//将一个字母转成小写
string Capital_or_Lower_String(string input){
    auto input_length_CLS = input.length() - 1;
    for(ll i = 0;i<= input_length_CLS;i++){
        if(input[i] >= 'A' && input[i] <= 'Z')
            input[i] += 32;
    }
    return input;
}//用于命令的转小写（大小写通用
ll ID(string a[],string input){
    long long res = 0;
    while(a[res] != ""){
        if(a[res] == input)
            return res;
        res++; 
    }
    return -1;
}//寻找元素于数组内下标，不存在则返回-1
ll ModCommandID(string input){
    for(ll i = 0;i<= mod_command_total - 1;i++){
        ll j = 0;
        string real_modcommand;
        while(mod_command_list[mod_command_total][j] != '.')
            real_modcommand += mod_command_list[mod_command_total][j++];
        if(real_modcommand == input)
            return i;
    }
    return -1;
}//寻找模组命令地址
string CommandRelatedMod(ll ID){
    string RelatedMod;
    ll i = 0;
    while(mod_command_list[ID][i] != '.')i++;
    i++;
    for(ll j = i;j<= mod_command_list[ID].length() - 1;j++)
        RelatedMod += mod_command_list[ID][j];
    return RelatedMod;
}//寻找特定命令所属的模组
bool OutsideWorld(ll x,ll y){
    if(x < 0 || x > MAX_INT || y < 0 || y > WorldYSize)//超出范围
        return 1;
    else
        return 0;
}//判断坐标是否超出世界
long long square(ll input){
    return input * input;
}//平方
vector<string> split(string input,char sep){
    vector<string> input_units;
    for(ll spliti = 0;spliti<input.length();spliti++){
        if(input[spliti]!=sep){
            input_units.push_back("");
            while(input[spliti]!=sep&& spliti < input.length())
                input_units[input_units.size()-1]+=input[spliti++];
        }
    }
    return input_units;
}
vector<int> tovect(int input[],int cpylen){
    vector<int>new_tov;
    for(int itov = 0;itov<cpylen;itov++)
        new_tov.push_back(input[itov]);
    return new_tov;
}
string numpress_str(vector<short> input){
    string output_nps;
    ll npslen = input.size();
    short now_int = input[0];
    for(ll npsi = 0;npsi<npslen;npsi++){
        ll conti_num = 0;
        while(input[npsi] == now_int && npsi<npslen){
            conti_num++;
            npsi++;
        }
        output_nps+=itos(now_int);
        if(conti_num>1)
            output_nps+=("*"+itos(conti_num));
        output_nps+="/";
        now_int = input[npsi];
        npsi--;
    }
    return output_nps;
}
vector<int> depress_str(string input){
    vector<string>unit_depr = split(input,'/');
    vector<int> out_deprstr;
    for(ll depi = 0;depi<unit_depr.size();depi++){
        vector<string>part_unit_depr = split(unit_depr[depi],'*');
        if(part_unit_depr.size() > 1){
            for(ll deppi = 0;deppi<strtoi(part_unit_depr[1]);deppi++)
                out_deprstr.push_back(strtoi(part_unit_depr[0]));
        }else
            out_deprstr.push_back(strtoi(part_unit_depr[0]));
    }
    return out_deprstr;
}
string getChunkCode(Chunk input){
    string output_gCC;
    output_gCC+=(itos(input.ID)+":");//区块号
    output_gCC+=(input.active + '0');//是否活跃
    output_gCC+=(input.discovered + '0');//是否探索过
    output_gCC+=":";
    vector<short> chunk_block;
    for(ll gcci = 0;gcci < WorldYSize * 16;gcci++)
        chunk_block.push_back(input.terrain[gcci]);
    output_gCC+=numpress_str(chunk_block);
    return output_gCC;
}
void PrintInfo(){
    while(!info_text.empty() && info_text.top() != "\n"){
        cout << "#" << language_prllinfo[lang] << setw(27) << (info_text.top() + "#") << endl;
        info_text.pop();
    }
}//输出系统提示信息
void PrintChat(){
    while(!info_chat.empty() && info_chat.top() != "\n"){
        cout << "#" << playername << ": " << info_chat.top() << endl;
        info_chat.pop();
    }
}//输出系统提示信息
void UpdateBlockInfo(){
    for(ll i = 0;i <= block_num - 1;i++){
        Block_List[i].ID = i;
        Block_List[i].hardness = block_hardness[i];
        Block_List[i].explosion_resistance = block_explosion_resistance[i];
        Block_List[i].name = block_name[i];
        Block_List[i].show_char = block_char[i];
    }
}//初始化方块信息
void AddTag(ll type,string block_list){
    for(ll i = 0;i<= block_list.length() - 1;i++){
        string addtag_block;
        if(block_list[i] != ','){
            while(block_list[i] != ',' && i <= block_list.length() - 1){
                addtag_block += block_list[i];
                i++;
            }
        }
        if((Block_List[ID(block_name,addtag_block)].tag).length() > 0)//若tag非空则加入逗号分隔
            Block_List[ID(block_name,addtag_block)].tag += ",";
        Block_List[ID(block_name,addtag_block)].tag += tag_type[type];
    }
}//为方块加入标签
bool TestTag(string target,string block_tag){
    string tag_block_list[32];
    ll tag_num_block = 0;
    for(ll i = 0;i<= block_tag.length() - 1;i++){
        string tagnow_block;
        if(block_tag[i] != ','){
            while(block_tag[i] != ',' && i <= block_tag.length() - 1)
                tagnow_block += block_tag[i++];
            tag_block_list[tag_num_block++] = tagnow_block;
        }
    }//分隔标签
    for(ll i = 0;i<= tag_num_block;i++){
        if(tag_block_list[i] == target)
            return 1;
    }
    return 0;
}//查找方块是否有特定的标签
void UpdateScreen(){
    short vision[16][16] = {-1},player_cover_block;
    ll startx_vision = playerx - 7,starty_vision = playery - 7,endx_vision = playerx + 8,endy_vision = playery + 8;
    for(ll y_upnow = starty_vision;y_upnow <= endy_vision;y_upnow++){
        for(ll x_upnow = startx_vision;x_upnow <= endx_vision;x_upnow++){
            ll copy_map_ID,distance_player = sqrt(square(abs(playerx - x_upnow)) + square(abs(playery - y_upnow)));
            if(y_upnow < 0 || y_upnow >= WorldYSize ||x_upnow > positive_crash_line || x_upnow < negative_crash_line){
                copy_map_ID = ID(block_name,"barrier");
            }else{
                if(world_chunk[gcID(x_upnow / 16)].entity[index(topox(x_upnow),y_upnow)] != 0){//优先打印实体
                    copy_map_ID = -1 - world_chunk[gcID(x_upnow / 16)].entity[index(topox(x_upnow),y_upnow)];
                    player_cover_block = world_chunk[gcID(x_upnow / 16)].terrain[index(topox(x_upnow),y_upnow)];
                }
                else if(world_chunk[gcID(x_upnow / 16)].terrain[index(topox(x_upnow),y_upnow)] != 14 && distance_player <= vision_size)//实体层当前方块无实体且在视距范围内，则打印地形
                    copy_map_ID = world_chunk[gcID(x_upnow / 16)].terrain[index(topox(x_upnow),y_upnow)];
                else
                    copy_map_ID = 14;
            }
            vision[y_upnow - starty_vision][x_upnow - startx_vision] = copy_map_ID;
        }
    }//将方块或实体打印到vision数组
    for(ll y_screen = 0;y_screen <= 17;y_screen++){
        for(ll x_screen = 0;x_screen <= 17;x_screen++){
            if(x_screen >= 1 && x_screen <= 16 && y_screen >= 1 && y_screen <= 16){
                if(vision[y_screen - 1][x_screen - 1] >= 0){
                    if(color_on){//当系统为linux且开启了颜色后才会显示
                        #ifdef __linux
                            cout << block_color[vision[y_screen - 1][x_screen - 1]]<< " ";
                        #else
                            if(!texture_loaded && texture_block[vision[y_screen - 1][x_screen - 1]] != "")
                                cout << Block_List[vision[y_screen - 1][x_screen - 1]].show_char;
                            else
                                cout << texture_block[vision[y_screen - 1][x_screen - 1]];
                        #endif
                    }
                    else{
                        if(texture_loaded && texture_block[vision[y_screen - 1][x_screen - 1]] != "")
                            cout << texture_block[vision[y_screen - 1][x_screen - 1]];
                        else
                            cout << Block_List[vision[y_screen - 1][x_screen - 1]].show_char;
                    }
                }
                else{
                    if(texture_loaded && texture_block[abs(vision[y_screen - 1][x_screen - 1] + 1)] != "")
                        cout << block_color[player_cover_block] <<texture_entity[abs(vision[y_screen - 1][x_screen - 1] + 1)]<<ce;
                    else
                        cout << entity_showchar[abs(vision[y_screen - 1][x_screen - 1] + 1)];;
                }
            }//方块
            else
                cout << screen[y_screen][x_screen];
            if(x_screen <= 16){
                if(y_screen == 0 || y_screen == 17)
                    cout << "#";
                else
                    cout << " ";
            }
            cout << "\033[m";
        }
        cout << endl;
    }//输出
}//三合一的屏幕更新（更新区块，复制到屏幕，显示屏幕）
string GameTimeShow[] = {"morning","noon","afternoon","evening","night","midnight"};
//游戏以64回合为一天
//一轮内第1-16轮为早晨/上午，17-24轮为中午,25-40轮为下午，41-48为傍晚，49-56为晚上，57-64为午夜
ll getGameTimeID(ll realtime){
    ll roundtime = realtime % 64 + 1;
    if(1 <= roundtime && roundtime <= 8)
        return 0;
    else if(9 <= roundtime && roundtime <= 24)
        return 1;
    else if(25 <= roundtime && roundtime  <= 32)
        return 2;
    else if(33 <= roundtime && roundtime <= 48)
        return 3;
    else if(49 <= roundtime && roundtime <= 56)
        return 4;
    else if(57 <= roundtime && roundtime <= 64)
        return 5;
    else
        return 0;
}
string setw_string(ll len,string input){
    string res_setw; 
    for(ll i = 0;i<= len - input.length();i++)
        res_setw+= " ";
    res_setw+=input;
    return res_setw;
}
class UI;
class item{
    public:
        UI *related_UI;//所属的UI
        ll std_ID;//物品的标准ID
        ll num;//物品的数量
        ll type_ID;//物品的类别ID
        ll damage;//物品耐久
        bool can_use;//物品能否被使用
    public:
        void add_itemnum(ll value){
            if(value+num<=item_maxstacknum[type_ID]&&value+num>=0)//在不超出范围的情况下增加
                num+=value;
        }//增减物品数量
        void edit_itemnum(ll value){
            if(value<=item_maxstacknum[type_ID])
                num=value;
        }//修改物品数量
        void use_check(){
            if(damage < 0 && damage != no_damage){
                can_use = 0;
                damage = 0;
            }
        }//检测物品是否能继续使用
};
string UIname_list[] = {"backpack","crafting_table","simple_crafting","furnace","chest","double_chest"};
ll UItype_num[6];
const ll UItype_maxItemNum[] = {32,9,4,3,32,64};
class UI{
    public:
        ll type;//类别
        item item_list[maxItemNum];
        string stdname;//标准名称
        string showname;//显示名称
        ll canuseItemNum;//可使用的物品数量
        ll std_ID;//标准序号
}backpack,simple_crafting,*nowvisit_UI;

void printItem(item input){
    cout<<(input.related_UI)->stdname<<","<<input.std_ID<<","<<input.type_ID<<","<<item_name[input.type_ID]<<","<<endl;
}
void printUI(UI input){
    cout << input.type<<","<<input.stdname<<","<<input.showname<<","<<input.canuseItemNum<<"[";
    for(ll j=0;j<input.canuseItemNum;j++){
        printItem(input.item_list[j]);
    }
    cout<<"end]\n";
}
item define_item(UI *define_UI,ll tID,ll num){
    item ret_defitem;
    ret_defitem.related_UI = define_UI;
    ret_defitem.std_ID = gamefile_item_num++;
    ret_defitem.num = num;
    ret_defitem.type_ID = tID;
    if(define_UI->canuseItemNum<UItype_maxItemNum[define_UI->type])
        define_UI->item_list[define_UI->canuseItemNum++]=ret_defitem;
    else
        ret_defitem.related_UI = NULL;
    return ret_defitem;
}
const ll UI_num = 4;
UI define_UI(ll type){
    UI ret_defUI;
    ret_defUI.stdname = UIname_list[type]+":"+itos(UItype_num[type]++);
    ret_defUI.showname = UIname_list[type];
    ret_defUI.type = type;
    ret_defUI.canuseItemNum = 0;
    ret_defUI.std_ID = gamefile_UI_num++;
    return ret_defUI;
}
void giveItem(UI *to_UI,ll type,ll num){
    item new_item = define_item(to_UI,type,num);
}
ll inrange(ll input,ll max,ll min = 0){
    if(input < min)
        return min;
    else if(input > max)
        return max;
    else
        return input;
}
void exchangeItem(UI *from_UI,UI *to_UI,ll id1,ll id2){
    swap(from_UI->item_list[inrange(id1,from_UI->canuseItemNum,0)],
         to_UI->item_list[inrange(id2,to_UI->canuseItemNum,0)]);
}
void clearItem(UI *op_UI,ll id){
    op_UI->item_list[inrange(id,op_UI->canuseItemNum,0)] = define_item(op_UI,ID(item_name,"NULL"),1);
}
ll nmax(ll a,ll b){
    return a>b?a:b;
}
void printBackpack(){
    cout << "#Player "<<playername<<endl;
    cout << "#Backpack" << endl;
    for(ll i = 0;i<backpack.canuseItemNum;i++)
        cout << "  >"<<(item_name[backpack.item_list[i].type_ID] + " " + itos(backpack.item_list[i].num))<<endl;
}
void BriefInformationPrint(){//简明信息
    if(lang == 0 || lang == 1){
        cout << "#" << setw_string(33,("Heart: " + itos(floor(player_heart)) + "   Hunger: " + itos(floor(player_hunger)) + "#"))<< endl; 
        cout << "#" << setw_string(35,(language_briefinfo[lang] + " x:" + itos(playerx) + " y:" + itos(playery) + "#")) << endl;//玩家坐标
        cout << "#" << setw_string(37,(language_briefinfo[lang + 3] + ": " + gamemode + "#")) << endl;//游戏模式
        cout << "#" << setw_string(40,(language_briefinfo[lang + 6] + "#")) << endl;//帮助提示
        cout << "#" << setw_string(33,("Time: " + GameTimeShow[getGameTimeID(game_time)] + "#")) << endl;
    }else{
        cout << "#" << setw_string(33,("Heart: " + itos(floor(player_heart)) + "   Hunger: " + itos(floor(player_hunger)) + "#"))<< endl; 
        cout << "#" << setw_string(33,(language_briefinfo[lang] + " x:" + itos(playerx) + " y:" + itos(playery) + "#")) << endl;//玩家坐标
        cout << "#" << setw_string(33,(language_briefinfo[lang + 3] + ": " + gamemode + "#")) << endl;//游戏模式
        cout << "#" << setw_string(33,(language_briefinfo[lang + 6] + "#")) << endl;//帮助提示
        cout << "#" << setw_string(33,("Time: " + GameTimeShow[getGameTimeID(game_time)] + "#")) << endl;
    }
    if(!info_text.empty())
        PrintInfo();//输出提示信息
    if(!info_chat.empty())
        PrintChat();//输出聊天信息
    cout << language_Command[lang];
}//基本信息显示
void UniversalInformationPrint(){
    clear
    cout << language_UIP[lang + 21] << worldname << endl;//世界名称
    cout << language_UIP[lang + 24] << playername << endl;//玩家名称
    cout << language_UIP[lang] << playerx << " y:" << playery << endl;//世界绝对坐标
    cout << language_UIP[lang + 3] << gamemode << endl;//当前游戏模式
    cout << language_UIP[lang + 6] << GameLatestVersion << endl;//游戏版本
    cout << language_UIP[lang + 15] << playerx - 7 << "," << playery - 7 << language_UIP[lang + 18] << playerx + 8 << "," << playery + 8 << ")" << endl;//玩家看到的区块坐标
    cout << language_UIPmods[lang] << endl;//模组信息
    cout << language_UIPmods[lang + 3] << endl;
    for(ll i = 0;i<= mod_total - 1;i++)//模组名称
        cout << mod_list[i] << endl;
    cout << language_UIPmods[lang + 6] << endl;//模组命令
    for(ll i = 0;i<= mod_command_total - 1;i++)
        cout << mod_command_list[i] << endl;
    cout << language_UIPmods[lang + 9] << endl;//模组方块
    for(ll i = 0;i<= mod_block_total - 1;i++)
        cout << mod_block_name[i] << "-" << mod_block_char[i] << endl;
    cout << language_UIPmods[lang + 12] << endl;//模组物品
    for(ll i = 0;i<= mod_item_total - 1;i++)
        cout << mod_item_name[i] << "-" << mod_item_char[i] << endl;
    cout << "#" << mod_total << language_UIPmods[lang + 15] << endl;//已加载的模组总数
    cout << language_Command[lang];//命令行
}//全部信息显示
void HelpPrint(){
    ll command_help = 1,choose_return = 1;
    clear
    cout << language_help1[lang] << endl;
    cout << language_help1[lang + 3] << endl;
    cout << language_help1[lang + 6] << endl;
    cout << language_help1[lang + 9] << endl;
    cout << language_help1[lang + 12] << endl;
    while(choose_return){
        cout << language_help2[lang];
        cin >> choose_return;
        if(choose_return == 1){
            clear
            cout << language_help3[lang] << GameLatestVersion << endl;
            cout << language_help3[lang + 3] << endl;
            cout << language_help3[lang + 6] << endl;
        }
        else if(choose_return == 2){
            clear
            cout << language_help4[lang] << endl;
            cout << language_help4[lang + 3] << endl;
            cout << language_help4[lang + 6] << endl;
            cout << language_help4[lang + 9] << endl;
            cout << language_help2[lang] << endl;
            cin >> command_help;
            clear
            if(command_help == 1){
                for(ll i = 0;i<= 15;i++)
                    cout << language_help5[lang + i * 3] << endl;
            }
            else if(command_help == 2)
                cout << language_help6[lang] << endl;
            else if(command_help == 3){
                cout << language_help7[lang] << endl;
            }
            else continue;
        }
        else if(choose_return == 3){
            clear
            for(ll i = 0;i<= 19;i++){
                cout << language_help8[lang + i * 3];
                if(i< 19)cout << endl;
            }
            cout << GameLatestVersion << endl;
        } 
        else if(choose_return == 4){
            clear
            cout << "模组的加入需要Addmod函数，格式为Addmod(模组名称,<模组新增命令1><模组新增命令2>,<模组新增方块1，外观显示字符><模组新增方块2，外观显示字符><...>,<模组新增物品1，外观显示字符><模组新增物品2，外观显示字符><...>)" << endl;
            cout << "每个模组在加入时会给新增的命令，方块，物品加上\".模组名称\"的后缀，用以区分不同模组的相同元素" << endl;
            cout << "加入时，需要在Command函数的\"else if(ModCommandID(comm) != -1){\"行加入模组的调用，对于每个模组都有一个ID，取决于加入的顺序,在游戏中就可以使用模组功能" << endl;
        }
        else break;
    }
}//教程
void printFile(){
    file_savetime = getTime();
    cout << filename<<","<<file_savetime<<";";//存档基本信息
    cout << playerx<<","<<playery<<","
         <<player_heart<<","<<player_hunger<<","<<player_full<<","<<player_oxygen
         <<","<<playername<<","<<worldname<<","<<seed<<","<<sea_level<<","
         <<gamemode<<","<<game_time<<
         ";";//玩家与世界基本信息
    usleep(12450);
    for(int pCi = 0;pCi <achievement_num;pCi++)
        cout<<achievement_get[pCi];
    cout << ","<<color_on<<","<<standardized_command<<","<<auto_jump<<","<<texture_loaded<< ";";//成就与设置信息
    usleep(12450);
    for(ll pCi = 0;pCi<world_chunk.size();pCi++){
        cout << getChunkCode(world_chunk[pCi])<<"#";//区块信息
        usleep(12450);
    }
    cout<<endl;
    string pass_pf;
    cout << "输入任意键继续>>>";
    cin >> pass_pf;
}
string getFileSizeUnit(string filein){
    string size_unit[] = {"B","Kb","Mb","Gb","Tb"};
    ll file_unitID = 0;
    double filelen = filein.length();
    while(filelen > 1024){
        file_unitID++;
        filelen/=1024.0;
    }
    return (itos(half_precision(filelen)) + size_unit[file_unitID]);
}
int getAchievementNum(){
    int ret_gan = 0;
    for(int igan = 0;igan < achievement_num;igan++){
        if(achievement_get[igan])
            ret_gan++;
    }
    return ret_gan;
}
string getTrueAchievement(){
    string ret_gta;
    for(int igta = 0;igta < achievement_num;igta++){
        if(achievement_get[igta]){
            ret_gta+=achievement_name[igta];
            if(igta < achievement_num - 1)
                ret_gta+=",";
        }
    }
    return ret_gta;
}
void Achievement(ll ID){
    string info_achievement;
    if(!achievement_get[ID]){
        info_achievement = language_achievement[lang] + language_achievement[ID * 3 + 3 + lang];
        info_text.push(info_achievement);
        achievement_get[ID] = 1;
    }
}//成就的输出
short structure_info[2][256] = {
    {5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,12,12,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,1,5,1,1,5,1,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,9,5,9,9,5,9,5,5,5,5,5,5,5,5,0,0,12,12,0,0,12,12,0,0,5,5,5,5,5,5,5,5,9,5,9,9,5,9,5,5,5,5,5,5,1,1,1,0,1,0,1,1,0,1,0,1,1,1,5,12,0,0,0,0,12,12,12,12,12,12,0,0,0,0,12
    },//神殿
};
/*
00## # # # # # # # # # # # # # #
01#
02#
03#
04#
05#
06#
07#
08#              $ $
09#            O O O O
10#          @   @ @   @
11#        O O O O O O O O
12#          |   | |   |
13#      O O $ $ O O $ $ O O
14#          |   | |   |
15#  @ @ @ O @ O @ @ O @ O @ @ @
16X$ O O O O $ $ $ $ $ $ O O O O $
17## # # # # # # X # # # # # # # #
*/
void SpawnStructure(ll x,ll y,ll type){
    for(ll z = x - 7;z<= x + 8;z++){
        for(ll v = y - 15;v <= y;v++)
            world_chunk[gcID(z / 16)].terrain[index(topox(z),v)] = structure_info[type][(z - x + 7) + (v - y + 15) * 16];
    }//强制覆盖地形
    for(ll z = x - 7;z<= x + 8;z++){
        ll structsy = y + 1;
        //cout << z << " " << structsy << "/";
        while(world_chunk[gcID(z / 16)].GetBlockInfo(z,structsy) == ID(block_name,"air") && structsy < WorldYSize){
            world_chunk[gcID(z/16)].terrain[index(topox(z),structsy++)] = ID(block_name,"cobblestone");
        }
    }//圆石基座
}
void SurfaceBlock(ll x,ll starty,ll biome_type,long long seed){
    ll chunkID = x / 16,rcID = gcID(chunkID);
    for(ll ny = WorldYSize;ny >= 0;ny--){
        if(ny >= starty){
            short nbID = 14;
            ll surface_incursion_p = 100 - (ny - starty) * 20,bedrock_incursion_p = (WorldYSize - ny) * 20;
            if(rand()%100 <= surface_incursion_p)//表层侵入
                nbID = biome_surface_block[biome_type];
            else if(rand()%100 >= bedrock_incursion_p)//基岩侵入
                nbID = ID(block_name,"bedrock");
            else
                nbID = ID(block_name,"stone");//石头
            world_chunk[rcID].terrain[index(topox(x),ny)] = nbID;
        }//海平面下
        else if(ny >= sea_level){
            if(biome_type == 5 || biome_type == ID(biome_name,"volcano"))
                world_chunk[rcID].terrain[index(topox(x),ny)] = ID(block_name,"lava");
            else if(biome_type != 1)
                world_chunk[rcID].terrain[index(topox(x),ny)] = ID(block_name,"water");
            else
                world_chunk[rcID].terrain[index(topox(x),ny)] = ID(block_name,"air");
        }//大于生成高度但小于海平面
        else//否则为空气
            world_chunk[rcID].terrain[index(topox(x),ny)] = ID(block_name,"air");
        //cout << world_chunk[chunkID].terrain[index(topox(x),ny)] << "/";
    }
}//生成每个生物群系的地表方块
void XmasLeave(ll size_tree,ll spawnx,ll spawny){
    ll start_treex = spawnx - size_tree / 2,end_treex = spawnx + size_tree / 2,now_y = spawny;
    while(start_treex <= end_treex){
        for(ll x = start_treex;x<= end_treex;x++){
            if(world_chunk[gcID(x / 16)].terrain[index(topox(x),now_y)] != ID(block_name,"wood"))
                world_chunk[gcID(x / 16)].terrain[index(topox(x),now_y)] = ID(block_name,"leave");
        }
        start_treex++;
        end_treex--;
        now_y--;
    }
}//生成圣诞树树叶
void SpawnTree(ll size_tree,ll spawnx,ll spawny,ll tree_type){
    srand(time(0));
    ll size_branch = (size_tree - rand()%size_tree) * 2;
    for(ll z = 0;z<= size_branch;z++)
        world_chunk[gcID(spawnx / 16)].terrain[index(topox(spawnx),spawny - z)] = ID(block_name,"wood");//树干
    if(tree_type == 0){
        ll midx_tree = spawnx,midy_tree = spawny - size_branch;
        for(ll x = spawnx - size_tree;x<= spawnx + size_tree;x++){
           for(ll a = midy_tree + size_tree / 1.3;a>= midy_tree - size_tree - size_tree / 1.5;a--){
                if(sqrt((x - spawnx)*(x - spawnx) + (a - midy_tree)*(a - midy_tree)) * 0.8 <= size_tree &&world_chunk[gcID(x / 16)].terrain[index(topox(x),a)] != ID(block_name,"wood") && !OutsideWorld(x,a))//未出世界+在可生成距离内+当前位置不是树干==>树叶（在最底层时会消减一层）
                world_chunk[gcID(x / 16)].terrain[index(topox(x),a)] = ID(block_name,"leave");
            }
        }
    }
    else if(tree_type == 1){
        ll xmas_tree_y = spawny - size_branch,size_leave = rand()%size_tree + 4;
        for(ll z = 0;z<= rand()%size_tree;z++){
            XmasLeave(size_leave,spawnx,xmas_tree_y);
            xmas_tree_y -= (rand()%size_tree / 2 + 2);
            size_leave -= (rand()%2 + 1);
        }//通过源代码还是可以使用圣诞树的，就当彩蛋吧
    }
    else
        DefaultUpdate;
    //新年快乐！
}//生成树木
void SpawnCave(ll startx,ll starty,ll size_cave){
    
}//生成洞穴
//函数ST,SST,PB,PM,SBlock,BBlock,TP,Fill,Clone,EI,GI,Command,TYC,SSBlock,STree,CBlock,CW,AM,WI为游戏玩法及内容执行函数
ll top_block(ll x,ll ID){
    for(ll j = 0;j<= WorldYSize - 1;j++){
        if(world_chunk[gcID(x / 16)].terrain[index(topox(x),j)] == ID)
            return j;
    }
    return -1;
}
ll top_notblock(ll x,ll ID){
    for(ll j = 1;j<= WorldYSize - 1;j++){
        if(world_chunk[gcID(x / 16)].terrain[index(topox(x),j)] != ID)
            return j;
    }
    return -1;
}
void UpdateBoarder(ll xlen,ll ylen){
    ll world_sx = MAX_INT / 2 - xlen / 2,world_ex = MAX_INT / 2 + xlen / 2,world_sy = WorldYSize / 2 -ylen / 2,world_ey = WorldYSize / 2 + ylen / 2;
    for(ll i = 0;i<= MAX_INT;i++){
        for(ll j = 0;j <= WorldYSize;j++){
            if(i == world_sx || i == world_ex || j == world_sy || j == world_ey)
                world_chunk[gcID(i / 16)].terrain[index(topox(i),j)] = ID(block_name,"barrier");
        }
    }
}
ll rangectrl(ll mini,ll value,ll maxi){
    if(value < mini)
        return mini;
    else if(value > maxi)
        return maxi;
    else
        return value;
}
double getTerrainY(double x,ll seed){
	ll seeda = floor(((seed * (seed + int(x * 8869311))) % seed) * x * x * x * x * ((seed % int(x + 1) + 1)));
	ll octaves = 10;
    double sumY = 0.0,resY = 0.0,freq = 1.0;
	for(ll z = 1;z<= octaves;z++){
	    sumY = TerrainNoise.noise(x * freq * z,seeda * freq * z,seeda);
	    resY += (sumY + 0.1) * 16.0 / freq;
	    freq*=2;
	}
	resY /= octaves;
	return resY;
}
void pwcl(){
    for(ll pwcli = 0;pwcli<world_chunk.size();pwcli++){
        cout << world_chunk[pwcli].ID;
        if(pwcli<world_chunk.size()-1)cout<<",";
    }
    cout <<endl;
}
void CreateChunk(ll chunk_ID,ll biome_chunk){
    world_chunk[world_chunk.size() - 1].ID = chunk_ID;
    double terrain_level = 0.0;
    ll terrain_realY = 0;
    for(ll i = 0;i< 16;i++){
        terrain_realY = getTerrainY((i + chunk_ID * 16 + 1) * 0.01,seed) * biome_sealevel[biome_chunk] + sea_level;
        SurfaceBlock(chunk_ID * 16 + i,rangectrl(0,terrain_realY,WorldYSize),biome_chunk,seed);
    }
    for(ll i = 0;i<= rand()%10;i++){
        srand(abs(seed + i * i));
        if(top_block(rand()%16 + chunk_ID * 16,ID(block_name,"grass")) != -1 && rand()%100 < biome_tree_density[biome_chunk])
            SpawnTree(rand()%biome_tree_maxsize[biome_chunk],rand()%16 + chunk_ID * 16,top_block(rand()%16 + chunk_ID * 16,ID(block_name,"grass")),0);
    }
    srand(((seed * (chunk_ID + 1) * (biome_chunk+1)) % seed) * int(sqrt(seed)));
    if(rand()%100 <= 10)
        SpawnStructure(chunk_ID + 7,top_notblock(chunk_ID + 7,ID(block_name,"air")),0);
    world_chunk[gcID(chunk_ID)].discovered = 1;
}//生成区块
ll getChunkBiome(ll chunk_ID,ll seed){
    srand(abs((int(chunk_ID * chunk_ID * chunk_ID * chunk_ID * chunk_ID * chunk_ID) * 8869311 + seed) % int(floor(sqrt(seed)))));
    ll res_biome = rand()%biome_num; 
    return res_biome;
}
void UpdateChunk(){
    chunk_now = playerx/16;
    Chunk temp_emptychunk1,temp_emptychunk2,temp_emptychunk3;
    if(!incvect(chunk_now-1) && chunk_now > 0){
        world_chunk.push_back(temp_emptychunk1);
        CreateChunk(chunk_now - 1,getChunkBiome(chunk_now - 1,seed));
    }
    if(!incvect(chunk_now)){
        world_chunk.push_back(temp_emptychunk2);
        CreateChunk(chunk_now,getChunkBiome(chunk_now,seed));
    }
    if(!incvect(chunk_now+1) && chunk_now < MAX_INT){
        world_chunk.push_back(temp_emptychunk3);
        CreateChunk(chunk_now + 1,getChunkBiome(chunk_now + 1,seed));
    }
}//更新区块-pre0.2.6.100加入随玩家移动而更新的区块
bool isthrough(ll x,ll y){
    return TestTag(tag_type[4],Block_List[world_chunk[gcID(x / 16)].GetBlockInfo(x,y)].tag);
}//是否为实体方块
string stdpos(ll x,ll y){
    return ("(" + itos(x) + "," + itos(y) + ")");
}//输出标准坐标
void PlayerBorn(ll spawnx_player,ll spawny_player){   
    bool flag_find_spot = 0;
    ll startx_spawn = spawnx_player,starty_spawn = spawny_player,endx_spawn = spawnx_player,endy_spawn = spawny_player; 
    while(!flag_find_spot){
        for(ll i = startx_spawn;i<= endx_spawn;i++){
            for(ll j = starty_spawn;j<= endy_spawn;j++){
                playerx = i,playery = j;
                UpdateChunk();
                if(world_chunk[gcID(i / 16)].terrain[index(topox(i),j)] == ID(block_name,"air")&& !isthrough(i,j + 1)){
                    world_chunk[gcID(i / 16)].entity[index(topox(i),j)] = 1;
                    playerx = i,playery = j;
                    flag_find_spot = 1;
                    break;
                }
            }
        }
        if(!flag_find_spot){
            startx_spawn--;
            endx_spawn++;
            starty_spawn--;
            endy_spawn++;
        }
        if((starty_spawn < 0 || endy_spawn > WorldYSize) && !flag_find_spot){
            world_chunk[gcID(spawnx_player / 16)].entity[index(topox(spawnx_player),spawny_player)] = 1;
            break;
        }
    }
    player_heart = 20.0;
    player_hunger = 20.00;
    player_full = 5.00;
    player_oxygen = 20;
}//会尽可能的靠近给定出生点出生，并避开方块
void PlayerMove(char direction){
    Achievement(0);
    if(direction >= 'A' &&direction <= 'Z')
        direction += 32;
    if(direction == 'w'){
        if(isthrough(playerx,playery - 1) && playery - 1 >= (WorldYSize- boarder_y) / 2){
            world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),playery)] = 0;
            world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),--playery)] = 1;
        }
    }//上移
    else if(direction == 's'){
        if(isthrough(playerx,playery + 1) && playery + 1 <= (WorldYSize+ boarder_y) / 2){
            world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),playery)] = 0;
            world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),++playery)] = 1;
        }
    }//下移
    else if(direction == 'a'){
        if(isthrough(playerx - 1,playery) && playerx - 1 >= (MAX_INT - boarder_x) / 2){
            world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),playery)] = 0;
            playerx--;
            world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),playery)] = 1;
        }else if(!isthrough(playerx - 1,playery) && isthrough(playerx - 1,playery - 1) && isthrough(playerx,playery - 1) && auto_jump){
            world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),playery)] = 0;
            playerx--;
            playery--;
            world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),playery)] = 1;
        }//自动跳跃
        else
            DefaultUpdate;
    }//左移
    else if(direction == 'd'){
        if(isthrough(playerx + 1,playery)){
            world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),playery)] = 0;
            playerx++;
            world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),playery)] = 1;
        }else if(!isthrough(playerx + 1,playery) && isthrough(playerx + 1,playery - 1) && isthrough(playerx,playery - 1) && auto_jump){
            world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),playery)] = 0;
            playerx++;
            playery--;
            world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),playery)] = 1;
        }//自动跳跃
        else
            DefaultUpdate;
    }//右移
    else//原地更新
        DefaultUpdate;
    //注：玩家移动逻辑为当目标方块带有through标签时就移动，在此情况下，树叶，空气，木头（是的木头也能穿过！）,水，岩浆都能穿过
}//玩家的基础移动
void Set(char direction,ll distance,string block_type){
    short setblockID;
    string info_set;
    Achievement(1);
    if(ID(block_name,block_type) != -1)//自带方块
        setblockID = ID(block_name,block_type);
        /*else if(ModBlockID(block_type) != -1)//模组方块
        setblockID = mod_block_char[ModBlockID(block_type)];
        */
    else{
        info_set = language_set[lang] + block_type;
        info_text.push(info_set);
        setblockID = 14;
    }
    direction = Lower_Char(direction);
    if(distance <= 16 && distance > 0){
    if(direction == 'w'){
        if((TestTag(tag_type[4],Block_List[world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery - distance)]].tag) || TestTag(tag_type[7],Block_List[world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery - distance)]].tag))&& playery - distance >= 0)
            world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery - distance)] =setblockID;
        else
            DefaultUpdate;
    }
    else if(direction == 's'){
        if((TestTag(tag_type[4],Block_List[world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery + distance)]].tag) || TestTag(tag_type[7],Block_List[world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery + distance)]].tag) ||  TestTag(tag_type[7],Block_List[world_chunk[playerx / 16].terrain[index(topox(playerx),playery + distance)]].tag)) && playery + distance <=WorldYSize)
            world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery + distance)] = setblockID;
        else
            DefaultUpdate;
    }
    else if(direction == 'a'){
        if((TestTag(tag_type[4],Block_List[world_chunk[gcID((playerx - distance) / 16)].terrain[index(topox(playerx - distance),playery)]].tag) || TestTag(tag_type[7],Block_List[world_chunk[gcID((playerx - distance) / 16)].terrain[index(topox(playerx - distance),playery)]].tag)) && playerx - distance >= 0)
            world_chunk[gcID((playerx - distance) / 16)].terrain[index(topox(playerx - distance),playery)] = setblockID;
        else
            DefaultUpdate;
    }
    else if(direction == 'd'){
        if((TestTag(tag_type[4],Block_List[world_chunk[gcID((playerx + distance) / 16)].terrain[index(topox(playerx + distance),playery)]].tag) || TestTag(tag_type[7],Block_List[world_chunk[gcID((playerx + distance) / 16)].terrain[index(topox(playerx + distance),playery)]].tag)))
            world_chunk[gcID((playerx + distance) / 16)].terrain[index(topox(playerx + distance),playery)] = setblockID;
        else 
            DefaultUpdate;
    }
    else
        DefaultUpdate;
    }
    else{
        info_text.push("Too far(" + itos(distance) + " > 16) for command /set to execute");
    }
}//放置方块
void Break(char direction,ll distance){
    Achievement(2);
    if(direction >= 'A' &&direction <= 'Z')
        direction += 32;
    if(0 < distance && distance <= 16){
    if(direction == 'w'){
        if(playery - distance > 0 && !TestTag(tag_type[0],Block_List[world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery - distance)]].tag))//检测目标方块是否带有unbreakable标签，如果无则破坏
            world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery - distance)] = 5;
        else
            Achievement(3);
    }
    else if(direction == 's'){
        if(playery + distance <= WorldYSize && !TestTag(tag_type[0],Block_List[world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery + distance)]].tag))
             world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery + distance)] = 5;
        else
            Achievement(3);
    }
    else if(direction == 'a'){
        if(playerx - distance > 0 &&!TestTag(tag_type[0],Block_List[world_chunk[gcID((playerx - distance) / 16)].terrain[index(topox(playerx - distance),playery)]].tag))
            world_chunk[gcID((playerx - distance) / 16)].terrain[index(topox(playerx - distance),playery)] = 5;
        else
            Achievement(3);
    }
    else if(direction == 'd'){
        if(playerx + distance <= MAX_INT && !TestTag(tag_type[0],Block_List[world_chunk[gcID((playerx - distance) / 16)].terrain[index(topox(playerx + distance),playery)]].tag))
            world_chunk[gcID((playerx - distance) / 16)].terrain[index(topox(playerx + distance),playery)] = 5;
        else
            Achievement(3);
    }
    else
        DefaultUpdate;
    }
    else
        info_text.push("Too far("+ itos(distance) + "> 16 for command /break to execute");
}//破坏方块
void Transportation(string command_transport){
    ll word_num_transport = 0,destinationx,destinationy,position_transport = 0;
    string words_transport[99];
    for(ll i = 0;i<= command_transport.length() - 1;i++){
        string word_transport;
        if(command_transport[i] != ' '){
            while(command_transport[i] != ' ' && i <= command_transport.length() - 1)
                word_transport += command_transport[i++];
            words_transport[word_num_transport] = word_transport;
            word_num_transport++;
        }
    }//找出单词
    if((words_transport[0])[0] == '~')
        position_transport += playerx;
    position_transport +=strtoi(words_transport[0]);
    destinationx = position_transport;
    position_transport = 0;
    if((words_transport[1])[0] == '~')
        position_transport += playery;    
    position_transport +=strtoi(words_transport[1]);
    destinationy = position_transport;
    string info_tp;
    playerx = destinationx;
    playery = destinationy;
    UpdateChunk();
    world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),playery)] = 0;
    world_chunk[gcID(destinationx / 16)].entity[index(topox(destinationx),destinationy)] = 1;
    info_tp = language_tp[lang + 3] + itos(destinationx) + " y = " + itos(destinationy) + ")";
    info_text.push(info_tp);
    if(playerx < 0 || playerx > MAX_INT || playery < 0 || playery > WorldYSize - 0)
        Achievement(4);
}//tp(传送指令),适用通配符，用于将玩家传送至指定位置
void Fill(string command_fill){
    ll word_num = 0,startx_fill,starty_fill,endx_fill,endy_fill,block_type_fill;
    char fill_block_char;
    string words_fill[99];
    for(ll fi = 0;fi< command_fill.length();fi++){
        string word_fill;
        if(command_fill[fi] != ' ')/*非空格*/{
            while(command_fill[fi] != ' ' && fi <= command_fill.length() - 1)
                word_fill += command_fill[fi++];
            words_fill[word_num++] = word_fill;
        }
    }//找出单词
    for(ll fi = 0;fi <= word_num;fi++){
        ll position_fill = 0;
        if((words_fill[fi])[0] == '~'){
            if(fi == 0 || fi == 2)
                position_fill += playerx;
            else if(fi == 1 || fi == 3)
                position_fill += playery;
        }//局部坐标转绝对坐标
        position_fill += strtoi(words_fill[fi]);
        if(fi == 0)
            startx_fill = position_fill;
        else if(fi == 1)
            starty_fill = position_fill;
        else if(fi == 2)
            endx_fill = position_fill;
        else if(fi == 3)
            endy_fill = position_fill;    
        else
            break;
    }
    ll fill_exact_ID = ID(block_name,words_fill[4]);
    string info_fill;
    ll rsxfill = min(startx_fill,endx_fill),rexfill = max(startx_fill,endx_fill),
        rsyfill = min(starty_fill,endy_fill),reyfill = max(starty_fill,endy_fill);
    //填充角的真实坐标
    long long fill_total = (rexfill - rsxfill + 1) * (reyfill - rsyfill + 1);
    if(fill_total <= maxinum_fill && !OutsideWorld(rsxfill,rsyfill) && !OutsideWorld(rexfill,reyfill)){
        for(ll i = rsxfill;i<= rexfill;i++){
            for(ll j = rsyfill;j<= reyfill;j++)
                world_chunk[gcID(i / 16)].terrain[index(topox(i),j)] = fill_exact_ID;
        }
        info_fill = language_fill[lang] + itos(fill_total) + language_fill[lang + 3];
        info_text.push(info_fill);
    }//成功填充
    else if(OutsideWorld(rsxfill,rsyfill) || OutsideWorld(rexfill,reyfill)){
        info_fill = language_fill[lang + 6] + itos(rsxfill) + "," + itos(rsyfill) + "),(" + itos(rexfill) + "," + itos(reyfill) + ")";
        info_text.push(info_fill);
    }//超出世界范围
    else{
        info_fill = language_fill[lang + 9] + itos(fill_total) + " >" + itos(maxinum_fill) + ")";
        info_text.push(info_fill);
    }//方块过多
}//fill(填充指令),适用通配符,以特定方块填充某个区域
void Clone(string comm_clone){
    ll word_num = 0,startx_clone = 0,starty_clone = 0,endx_clone = 0,endy_clone = 0,copy_startx = 0,copy_starty= 0;
    string words_clone[99];
    for(ll i = 0;i<= comm_clone.length() - 1;i++){
        if(comm_clone[i] != ' ')/*非空格*/{
            while(comm_clone[i] != ' ' && i <= comm_clone.length() - 1)
                words_clone[word_num] += comm_clone[i++];
            word_num++;
        }
    }//找出单词
    for(ll i = 0;i <= word_num;i++){
        ll position_clone = 0;
        if(words_clone[i][0] == '~'){
            if(i == 0 || i == 2 || i == 4)
                position_clone += playerx;
            else
                position_clone += playery;

        }//局部坐标转绝对坐标
        position_clone += strtoi(words_clone[i]);
        if(i == 0)
            startx_clone = position_clone;
        else if(i == 1)
            starty_clone = position_clone;
        else if(i == 2)
            endx_clone = position_clone;
        else if(i == 3)
            endy_clone = position_clone;    
        else if(i == 4)
            copy_startx = position_clone;
        else if(i == 5){
            copy_starty = position_clone;
            break;
        }
    }
    string info_clone;
    ll clone_startx = min(startx_clone,endx_clone),clone_starty = min(starty_clone,endy_clone);
    if(OutsideWorld(clone_startx,clone_starty) || OutsideWorld(max(startx_clone,endx_clone),max(starty_clone,endy_clone)) || OutsideWorld(copy_startx,copy_starty)){//超出世界范围
        info_clone = language_clone[lang] + itos(clone_startx) + "," + itos(clone_startx) + ")(" + itos(max(startx_clone,endx_clone)) + "," + itos(max(starty_clone,endy_clone)) + "),(" + itos(copy_startx) + "," + itos(copy_starty) + ")";
        info_text.push(info_clone);
    }
    else{
        for(ll i = 0;i <= max(starty_clone,endy_clone) - clone_starty;i++){
            for(ll j = 0;j <= max(startx_clone,endx_clone) - clone_startx;j++){
                world_chunk[gcID((copy_startx + j) / 16)].terrain[index(topox(copy_startx + j),copy_starty + i)] = world_chunk[gcID((copy_startx + j) / 16)].terrain[index(topox(clone_startx + j),clone_starty + i)];
            }
        }
        info_clone = language_clone[lang + 3] + itos(clone_startx) + "," + itos(clone_startx) + "),(" + itos(max(startx_clone,endx_clone)) + "," + itos(max(starty_clone,endy_clone)) + language_clone[lang + 9] + itos(copy_startx) + "," + itos(copy_starty) + ")";
    }
}//clone(克隆指令),适用通配符，将一个地区的方块复制到另一个地区
void TestBlock(char direction_test,ll distance){
    direction_test = Lower_Char(direction_test);
    string test_block_name,warningtext_test;
    if(direction_test == 'a' && !OutsideWorld(playerx - distance,playery))
        test_block_name = block_name[world_chunk[gcID((playerx - distance) / 16)].terrain[index(topox(playerx - distance),playery)]];
    else if(direction_test == 'd' && !OutsideWorld(playerx + distance,playery))
        test_block_name = block_name[world_chunk[gcID((playerx + distance) / 16)].terrain[index(topox(playerx + distance),playery)]];
    else if(direction_test == 'w' && !OutsideWorld(playerx,playery - distance))
        test_block_name = block_name[world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery - distance)]];
    else if(direction_test == 's' && !OutsideWorld(playerx,playery + distance))
        test_block_name = block_name[world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery + distance)]];
    else if(direction_test != 'a' && direction_test != 'd' && direction_test != 'w' && direction_test != 's'){
        warningtext_test = language_testblock[lang];
        warningtext_test += direction_test;
    }
    else
        warningtext_test += language_testblock[lang + 3];
    if(warningtext_test != "\n")
        info_text.push(warningtext_test);
    if(test_block_name != "\n"){
        string test_command = language_testblock[lang + 6] + test_block_name;
        info_text.push(test_command);
    }
}//查询方块名称
/*
b = bool类型参数
i = ll类型参数
s = string类型参数
三种类型皆从字符串转化而来
*/
string depress_para(char para_type){
    if(para_type == 'b')
        return "bool";
    else if(para_type == 'i')
        return "ll";
    else if(para_type == 's')
        return "string";
    else
        return "default";
}//生成错误信息-标准形式的参数
string depress_paralist(string paralist){
    string res_dp;
    for(ll i = 0;i<= paralist.length() - 1;i++){
        res_dp += depress_para(paralist[i]);
        if(i < paralist.length() - 1)
            res_dp += ",";
    }
    return res_dp;
}
string success_gamerule(ll type){
    if(type >= 0)
        return ("gamerule." + gamerule_list[type] + language_gamerule[lang]);
    else
        return "default";
}
string bool_para(bool input){
    if(input)
        return "true";
    else
        return "false";
}
void Gamerule(string gamerule_input){
    string words_gamerule[999];
    Achievement(6);
    ll words_num_gamerule = 0,length_Gi = gamerule_input.length() - 1;
    for(ll i = 0;i<= length_Gi;i++){
        if(gamerule_input[i] != ' '){
            while(gamerule_input[i] != ' '&& i <= length_Gi)
                words_gamerule[words_num_gamerule] += gamerule_input[i++];
            words_num_gamerule++;
        }
    }//分词系统
    ll visit_parameterID = ID(gamerule_list,words_gamerule[0]);//第一个单词用于识别ID
    ll parameter_listi[99] = {0},ipara_num = 0,bpara_num = 0,spara_num = 0;
    bool parameter_listb[99] = {0};
    string parameter_lists[99];
    if(1 > words_num_gamerule){
        info_text.push(language_gamerule[lang + 3]);
        return ;
    }
    for(ll i = 1;i<= words_num_gamerule;i++){
        char parameter_type = gamerule_parameter[visit_parameterID][i - 1];
        if(parameter_type == 'b')
            parameter_listb[bpara_num++] = strtoi(words_gamerule[i]);
        else if(parameter_type == 'i')
            parameter_listi[ipara_num++] = strtoi(words_gamerule[i]);
        else if(parameter_type == 's')
            parameter_lists[spara_num++] = words_gamerule[i];
    }
    switch(visit_parameterID){
        case 0://color-颜色开启或关闭
            if(bpara_num == 1){//正确的数目
                color_on = parameter_listb[0];
                info_text.push(success_gamerule(0) + bool_para(parameter_listb[0]));
            }
            else{
                if(bpara_num < 1)//无参数
                    info_text.push("Error: Missing parameter(type = " + depress_paralist(gamerule_parameter[0]) + ") for command:/gamerule color");
                    //翻译："错误:对于/gamerule color指令缺失了布尔类型参数"
                else
                    info_text.push("Error: Too many parameters for command: /gamerule color which required only 1");
                    //翻译："错误:/gamerule color指令"
            }
            break;
        case 1://vision_size-能看见的地图大小（最大16*16,标准视野）
            if(ipara_num == 1){
                vision_size = parameter_listi[0];
                info_text.push(success_gamerule(1) + itos(parameter_listi[0]));
            }    
            break;
        case 2://boarder_size-边界大小
            if(ipara_num == 2){
                boarder_x = parameter_listi[0],boarder_y = parameter_listi[1];
                UpdateBoarder(boarder_x,boarder_y);
                info_text.push(success_gamerule(2) + itos(parameter_listi[0]) + "*" + itos(parameter_listi[1]));
            }
            break;
        case 3://standardized_command-标准化命令（不能使用不包含/标识符的命令）
            if(bpara_num == 1){
                standardized_command = parameter_listb[0];
                info_text.push(success_gamerule(3) + bool_para(parameter_listb[0]));
            }
            break;
        case 4://maxinum_fill-方块填充的最大数量,调整/fill指令的上限
            if(ipara_num == 1){
                maxinum_fill = parameter_listi[0];
                info_text.push(success_gamerule(4) + itos(parameter_listi[0]));
            }  
            break;
        case 5://player_name-玩家的名字
                playername = parameter_lists[0];
                info_text.push(success_gamerule(5) + parameter_lists[0]);
                info_text.push("Hello," + playername);
            break;
        case 6://world_name-世界的名字
                worldname = parameter_lists[0];
                info_text.push(success_gamerule(6) + parameter_lists[0]);
                info_text.push("Hello," + worldname + "!");
            break;
        case 7://auto_jump-自动跳跃
                auto_jump = parameter_listb[0];
                info_text.push(success_gamerule(7) + bool_para(parameter_listb[0]));
            break;
        case 8://respawn_poll-重生点
            if(parameter_listi[0] > 0 && parameter_listi[1] > 0 && parameter_listi[1] < WorldYSize){
                respawnx = parameter_listi[0];
                respawny = parameter_listi[1];
                info_text.push(success_gamerule(8) + itos(parameter_listi[0]) + "," + itos(parameter_listi[0]));
            }
            break;
        case 9:
            texture_loaded = parameter_listb[0];
            info_text.push(success_gamerule(9) + bool_para(parameter_listb[0]));
            break;
        default:
            info_text.push("Unknowing gamerule: " + words_gamerule[0]);
            break;
    }
}
//纪念消失的ConnectBlock函数，有一日等仙人掌加入，我们再会（泪目）
void Eat(){
    player_hunger+= 5;
    if(player_hunger > 20){
        player_full = player_hunger- 20;
        player_hunger = 20;
    }
}//过渡命令/eat，用于增加饥饿值
void Setblock(ll x,ll y,string type){
    if(x < 0 || x > MAX_INT || y < 0 || y > WorldYSize)
        info_text.push(language_setblock[lang]);
    else{
        if(ID(block_name,type) != -1)
            world_chunk[gcID(x / 16)].terrain[index(topox(x),y)] = ID(block_name,type); 
        else
            info_text.push((language_setblock[lang + 3] + ": " + type));
    }
}
void Command(string command_all){
    string command_group[256],warningtext;//最多256条命令
    item new_item;
    UI *exc_UI1,*exc_UI2;
    ll group_size = 0,total_length = command_all.length() - 1;//group_size-命令总数计数,total_length-总长度
	for(ll i = 0;i<= total_length;i++){
	    if(command_all[i] != ';'){
	        while(command_all[i] != ';' && i <= total_length)
	            command_group[group_size] += command_all[i++];
	        string command_words[99],spara_command[99],now_command = command_group[group_size];
	        ll ipara_command[99],spara_cnum = 0,cpara_cnum = 0,ipara_cnum = 0,separated_length = command_group[group_size].length() - 1,word_commnum = 0;
	        char cpara_command[99];//char参数
	        for(ll j = 0;j <= separated_length;j++){
	            if(now_command[j] != ' '){
	                while(now_command[j] != ' ' && j <= separated_length)
	                    command_words[word_commnum] += now_command[j++];
	                word_commnum++;
	            }
	        }
	        ll command_ID = ID(command_name,command_words[0]);//识别命令
	        ll ID_langname=0,ID_gamemodename = 0;
	        if(command_parameter[command_ID] == "long"){//长参数命令-自动解析单词组的命令
	            string long_type_para;
	            for(ll j = 1;j<= word_commnum;j++){
	                long_type_para += command_words[j];
	                if(j < word_commnum)
	                    long_type_para += " ";
	            }
	            spara_command[0] = long_type_para;
	        }
	        else if(command_parameter[command_ID] != "n"){//判断是否为无参数命令
	            for(ll j = 1;j<= word_commnum;j++){
	                char paratype_command = command_parameter[command_ID][j - 1];
	                if(paratype_command == 'c')
	                    cpara_command[cpara_cnum++] = command_words[j][0];
	                else if(paratype_command == 'i')
	                    ipara_command[ipara_cnum++] = strtoi(command_words[j]);
	                else
	                    spara_command[spara_cnum++] = command_words[j];
	            }
	        } 
	        else;//不更新任何东西
	        switch(command_ID){
	            case 0://w
	                if(!standardized_command)
	                    PlayerMove(command_words[0][0]);
	                else
	                    warningtext = language_warncommand[lang + 3] + command_words[i][0];
	                break;
	            case 1://a
	                if(!standardized_command)
	                    PlayerMove(command_words[0][0]);
	                else
	                    warningtext = language_warncommand[lang + 3] + command_words[i][0];
	                break;
	            case 2://s
	                if(!standardized_command)
	                    PlayerMove(command_words[0][0]);
	                else
	                    warningtext = language_warncommand[lang + 3] + command_words[i][0];
	                break;
	            case 3://d
	                if(!standardized_command)
	                    PlayerMove(command_words[0][0]);
	                else
	                    warningtext = language_warncommand[lang + 3] + command_words[i][0];
	                break;
	            case 4:// /move
	                PlayerMove(cpara_command[0]);
	                break;
	            case 5:// /set
	                Set(cpara_command[0],ipara_command[0],spara_command[0]);
	                break;
	            case 6:// /break
	                Break(cpara_command[0],ipara_command[0]);
	                break;
	            case 7:// /fill
	                Fill(spara_command[0]);
	                break;
	            case 8:// /tp
	                Transportation(spara_command[0]);
	                break;
	            case 9:// /clone
	                Clone(spara_command[0]);
	                break;
	            case 10:// /gamemode
	                ID_gamemodename = ID(gamemode_name,spara_command[0]);
	                if(ID_gamemodename != -1)
	                    gamemode = gamemode_name[ID_gamemodename];
	                else if(spara_command[0].length() == 1 && (spara_command[0][0] == '0' || spara_command[0][0] == '1' || spara_command[0][0] == '2'))
	                    gamemode = gamemode_name[strtoi(spara_command[0])];
                    else
	                    warningtext = language_warncommand[lang] + spara_command[0];//无符合模式，则显示警告
	                break;
	            case 11:// /help
	                HelpPrint();
	                break;
	            case 12:// /open
	                active_screen = spara_command[0];
	                break;
	            case 13:// /gamerule
	                Gamerule(spara_command[0]);
	                break;
	            case 14:// /testblock
	                TestBlock(cpara_command[0],ipara_command[0]);
	                break;
	            case 15:// /kill
	                world_chunk[gcID(playerx / 16)].entity[index(topox(playerx),playery)] = ' ';
	                PlayerBorn(respawnx,respawny);
                    info_text.push(playername + language_kill[lang]);
	                break;
	            case 16:// /eat
	                Eat();
	                break;
	            case 17:// /setblock
	                Setblock(ipara_command[0],ipara_command[1],spara_command[0]);
	                break;
	            case 18:// /seed
	                info_text.push((worldname + " - seed: " + itos(seed)));
	                break;
	            case 19:// /biome
	                info_text.push(("Now Biome: " + biome_name[getChunkBiome(playerx / 16,seed)]));
	                break;
	            case 20:// /say
	                info_chat.push(spara_command[0]);
	                break;
	            case 21:// /lang
	                ID_langname = ID(language_name,spara_command[0]);
	                if(ID_langname != -1)
	                    lang = ID_langname;
	                else if(spara_command[0][0] == '0' ||spara_command[0][0] == '1' || spara_command[0][0] == '2')
	                    lang = strtoi(spara_command[0]);
                    else
	                    warningtext = language_warncommand[lang] + spara_command[0];//无符合模式，则显示警告
	                break;
	            case 22:// /give 
                    while(ipara_command[0]){
                        if(ipara_command[0] >= 64){
	                        new_item = define_item(nowvisit_UI,ID(item_name,spara_command[0]),64);
	                        ipara_command[0]-=64;
                        }else{
                            new_item = define_item(nowvisit_UI,ID(item_name,spara_command[0]),ipara_command[0]);
                            ipara_command[0] = 0;
                        }
                    }
	                break;
	            case 23:// /throw
	                clearItem(nowvisit_UI,inrange(ipara_command[0],0,nowvisit_UI->canuseItemNum));
	                break;
	            /*case 24:// /exc
	                
	                switch(ID(UI_place,spara_command[0])){
	                    case 0:
	                        exc_UI1 = &backpack;
	                        break;
	                    case 2:
	                        exc_UI1 = &simple_crafting;
	                    default:
	                        exc_UI1 = NULL;
	                }switch(ID(UI_place,spara_command[1])){
	                    case 0:
	                        exc_UI2 = &backpack;
	                        break;
	                    case 2:
	                        exc_UI2 = &simple_crafting;
	                        break;
	                    default:
	                        exc_UI2 = NULL;
	                }
	                exchangeItem(exc_UI1,exc_UI2,ipara_command[0],ipara_command[1]);
	                break;
	             */
	             case 24:// /savefile
	                    cout << "Start to print file" << endl;
	                    filename = spara_command[0];
	                    info_text.push("Starting to create file "+filename + " 's code");
	                    printFile();
	                    break;
	            default:
	                if(separated_length > 1)//如果不是空命令才会警告
	                    warningtext = language_warncommand[lang + 3] + command_words[i][0];//未知命令警告
	        }//分命令的处理
	        group_size++;//更新
	    }//分割完毕后处理
	}//分割总命令
	if(color_on)//颜色刷新保护
        usleep(750000);//延时防止故意持续刷新导致崩溃
}//用于命令的处理
//1.3.4更新！命令组加入！
void Addmod(string mod_name,string mod_command,string mod_block_add,string mod_item_add){
    mod_list[mod_total++] = mod_name;//单个的名字
    if(Capital_or_Lower_String(mod_command) != "none"){
        for(ll i = 0;i <= mod_command.length() - 1;i++){
            if(mod_command[i] == '<')/*碰到命令标识符*/{
                i++;
                while(mod_command[i] != '>')//在碰到右标识符前持续读入命令数据
                    mod_command_list[mod_command_total] += mod_command[i++];
                mod_command_list[mod_command_total] += ("." + mod_name);
                mod_command_total++;
            }
        }//解析模组新增命令并写入
    }
    if(Capital_or_Lower_String(mod_block_add) != "none"){
        for(ll i = 0;i <= mod_block_add.length() - 1;i++){
            if(mod_block_add[i] == '<')/*碰到方块标识符*/{
                i++;
                while(mod_block_add[i] != ',')//在碰到逗号前持续读入方块名称
                    mod_block_name[mod_block_total] += mod_block_add[i++];
                mod_block_name[mod_block_total] += ("." + mod_name);//添加模组标识
                mod_block_char[mod_block_total++] = mod_block_add[i+ 1];
            }
        }//解析模组新增方块并写入
    }
    if(Capital_or_Lower_String(mod_item_add) != "none"){
        for(ll i = 0;i <= mod_item_add.length() - 1;i++){
                if(mod_item_add[i] == '<')/*碰到物品标识符*/{
                i++;
                while(mod_item_add[i] != ',')//在碰到逗号前持续读入物品名称
                    mod_item_name[mod_item_total] += mod_item_add[i++];
                    mod_item_name[mod_item_total] += ("." + mod_name);
                    mod_item_char[mod_item_total++] = mod_item_add[i+ 1];
            }
        }//解析模组新增物品并写入
    }
}//1.2.3更新--模组的初步兼容！！！
bool readFile(string input){
    //懒得写函数，直接复制粘贴了
    vector<string> unit_file = split(input,';');
    vector<string> funit_file = split(unit_file[0],',');
    vector<string> pwunit_file = split(unit_file[1],',');
    vector<string> wcunit_file = split(unit_file[3],'#');
    string std_fillpw[] = {"16384","192","10.0","10.0","5.0","10.0","Pasli","World SU-21903","8869311","192","creative","0"};
    //解析玩家与世界基本信息
    if(unit_file.size()<3){
        cout << red<<"存档格式错误";
        cout << "错误：解析中获取的参数数量少于规定("<<funit_file.size()<<" < 3)"<<ce<< endl;
        cout << "可能原因："<<endl;
        cout << "1.名称内存在非法字符(,或;)" << endl;
        cout << "2.人为修改过存档"<< endl;
        cout << "\033[31m 存档基本信息错误，无法继续解析 \033[m" << endl;
        cout << "\033[33m 若有修复存档需要可根据Wiki所列格式进行修复 \033[m" << endl;
        cout << "输入任意键继续 >>>";
        string file_end1;
        cin >> file_end1;
        return 0;
    }else{
        if(funit_file.size()<2){
            cout << red<<"存档格式错误";
            cout << "错误：解析中获取的参数数量少于规定("<<funit_file.size()<<" < 2)"<<ce<< endl;
            cout << "可能原因："<<endl;
            cout << "1.名称内存在非法字符(,或;)" << endl;
            cout << "2.人为修改过存档"<< endl;
            cout << "\033[31m 存档信息错误，已对缺失信息格式化赋值，不保证与原先相同 \033[m" << endl;
            cout << "\033[33m 若有修复存档需要可根据Wiki所列格式进行修复 \033[m" << endl;
            file_savetime = getTime();//标准时间
            if(funit_file.size()<1)
                filename = "Format File";//标准格式化
        }else{
            filename = funit_file[0];
            file_savetime = funit_file[1];
        }
        //pwunit_file = player & world unit of file
        if(pwunit_file.size()<12){
            cout << red<<"存档格式错误";
            cout << "错误：解析中获取的参数数量少于规定("<<pwunit_file.size()<<" < 12)"<<ce<< endl;
            cout << "可能原因："<<endl;
            cout << "1.存档名称内存在非法字符(,或;)" << endl;
            cout << "2.人为修改过存档"<< endl;
            cout << "\033[31m 存档信息错误，已对缺失信息格式化赋值，不保证与原先相同 \033[m" << endl;
            cout << "\033[33m 若有修复存档需要可根据Wiki所列格式进行修复 \033[m" << endl;
            while(pwunit_file.size()<13)
                pwunit_file.push_back(std_fillpw[pwunit_file.size()-1]);
        }
        playerx = strtoi(pwunit_file[0]);
        playery = strtoi(pwunit_file[1]);
        respawnx = playerx;
        respawny = playery;
        player_heart = stof(pwunit_file[2]);
        player_hunger = stof(pwunit_file[3]);
        player_full = stof(pwunit_file[4]);
        player_oxygen = stof(pwunit_file[5]);
        playername = pwunit_file[6];
        worldname = pwunit_file[7];
        seed = strtoi(pwunit_file[8]);
        sea_level = strtoi(pwunit_file[9]);
        gamemode = pwunit_file[10];
        game_time = strtoi(pwunit_file[11]);
        //成就与设置信息
        vector<string> asunit_file = split(unit_file[2],',');
        //asunit_file = Achievement & Setting unit of file
        if(asunit_file.size() < 5){
            string std_fillas[] = {cpystr("0",achievement_num),"0","0","0","0"};
            while(asunit_file.size()<5)
                asunit_file.push_back(std_fillas[asunit_file.size()-1]);
        }
        for(int iasuf = 0;iasuf<asunit_file[0].length();iasuf++)
            achievement_get[iasuf] = strtoi(to_str(asunit_file[0][iasuf]));
        color_on = strtoi(asunit_file[1]);
        standardized_command = strtoi(asunit_file[2]);
        auto_jump = strtoi(asunit_file[3]);
        texture_loaded = strtoi(asunit_file[4]);
        for(ll iwc = 0;iwc<wcunit_file.size();iwc++){
            vector<string> single_chunk = split(wcunit_file[iwc],':');
            Chunk newsingle_chunk;
            newsingle_chunk.ID = strtoi(single_chunk[0]);
            newsingle_chunk.active = strtoi(to_str(single_chunk[1][0]));
            newsingle_chunk.discovered = strtoi(to_str(single_chunk[1][1]));
            vector<int> getchunkblock = depress_str(single_chunk[2]);
            for(int igcc = 0;igcc<getchunkblock.size();igcc++)
                newsingle_chunk.terrain[igcc]=getchunkblock[igcc];
            world_chunk.push_back(newsingle_chunk);
        }
        //区块信息
        cout << lime<<"存档解析成功"<<ce<< endl;
        return 1;
    }
}
//层级：
// ,    --仅适用于玩家信息
//a;b;c --一级操作符，分割玩家信息，UI信息与地图信息
// a#b  --二级操作符，分割地图中的区块
// a/b  --三级操作符，分割方块信息
// a*b  --四级操作符，分割方块与数量
void MoreFile(){
    cout << "     存档详细信息" << endl;
    cout << "1.玩家信息：" << endl;
    cout << "    player_heart:"<<player_heart << endl;
    cout << "    player_hunger:"<<player_hunger << endl;
    cout << "    player_full:"<<player_full << endl;
    cout << "    player_oxygen:"<<player_oxygen << endl;
    cout << "    gamemode:"<<gamemode<<endl;
    cout << "    game_time:"<<game_time << endl;
    cout << "2.设置信息：" << endl;
    cout << "    color_on:"<<bool_para(color_on) << endl;
    cout << "    standardized_command:"<<bool_para(standardized_command) << endl;
    cout << "    auto_jump:"<<bool_para(auto_jump) << endl;
    cout << "    load_texture:"<<bool_para(texture_loaded) << endl;
    cout << "3.世界信息：" << endl;
    cout << "    已加载区块：";
    pwcl();
    cout << "    玩家周围信息：" << endl;
    for(ll ymf = playery - 7;ymf <= playery + 8;ymf++){
        cout << "    ";
        for(ll xmf = playerx - 7;xmf <= playerx + 8;xmf++){
            if(0<=xmf && xmf <= positive_crash_line && ymf >= 0 && ymf < WorldYSize)
                cout << block_char[world_chunk[gcID(xmf / 16)].terrain[index(topox(xmf),ymf)]]<<" ";
            else
                cout<< block_char[ID(block_name,"barrier")];
        }
        cout<<endl;
    }
    cout << lime<<"输出结束"<<ce<< endl;
}
int WorldInit(bool skip){//世界初始化
    clear
    AddTag(0,"barrier,bedrock");//unbreakable标签，用于判断是否能破坏
    AddTag(1,"furnace,crafting_table");//lleraction标签，用于判断是否能交互
    AddTag(2,"grass,dirt");//plant标签，用于判断是否能生长植物
    AddTag(3,"stone,cobblestone");//ore_replaceable标签，用于判断是否生成矿物
    AddTag(4,"air,wood,leave,water,lava");//through标签，用于判断玩家是否能通过方块
    AddTag(5,"sand,leave");//gravity标签，用于判断方块是否受重力影响
    AddTag(6,"water,lava");//oxygen标签，用于判断是否要消耗氧气
    AddTag(7,"water,lava");//fluid标签，用于判断是否为流体
    //目前能想到的最简单的定义方式......一键定义+可视化
    UpdateBlockInfo();
    if(!skip){
        cout << language_initilize[lang];
        cin.ignore(1);
        getline(cin,worldname);
        cout << language_initilize[lang +3];
        getline(cin,playername);
        clear
        cout << language_initilize[lang + 6] << playername << endl;
        sleep(1);
        p(language_initilize[lang +9]);
        sleep(1);
        clear
    }
    cout << "世界选择：" << endl;
    cout << "1.加载已有存档" << endl;
    cout << "2.创建新世界" << endl;
    cout << ">>>";
    int file_read = 0;
    cin >> file_read;
    if(file_read == 1){
        cout << "请进入源代码，将下面定义的file变量赋值为所保存的存档码" << endl;
        string file = "testfile_allblock,2021/07/25 17:00:42;1024,186,20,20,5,20,Pasli,World SU-21903,8869311,192,creative,16;110001,1,0,1,0;0:01:8*32/0*3/8/0*4/8*4/0/8*2/0*2/8/0/8/0/8/0*2/8/0/8/0/8*2/0/8/0/8/0*4/8/0*4/8*3/0*1024/2/0*2/2/0*4/2*2/0*8/2*2/0*2/2*4/0*5/2*4/0/2/0*3/2*4/0*4/2/0/5/2*9/0*2/2*4/5*3/2*2/5*3/0/2*2/0*2/2/5*10/2/5/2*3/5*14/2/5*2884/#1:01:8*22/0/8*2/0/8*4/0/8*2/0/8/0/8*4/0/8/0/8*4/0/8/0*3/8*2/0*2/8*3/0*3/8/0*2/8/0*5/8/0*7/8/0*1635/1/0*15/1/0*15/1/0*15/1/0*15/5/0*15/5/0*15/5/0*15/5/0*15/5/0*14/1/5/0*14/1/5/0*14/1/5/0*14/1/5/0*14/5*2/0*14/5*2/0*14/5*2/0*13/1/5*2/0*14/5*2/0*13/1/5*2/1/0*12/1/5*2/1/0*12/1/5*2/1/0*12/5*3/1/0*12/5*4/0*12/5*4/0*12/5*4/0*12/5*4/0*5/1/0*6/5*4/0*12/5*4/0*4/1/0*7/5*4/1/0*4/1/0*6/5*5/0*4/5/0*6/5*5/0*3/1/5/0*6/5*5/0*3/1/5/0*5/1/5*5/0*3/5*2/0*5/1/5*5/0*3/5*2/0*5/1/5*5/0*3/5*2/0*5/5*6/0*3/5*2/0*5/5*6/0*3/5*2/0*5/5*6/0*3/5*2/0*5/5*6/0*3/5*2/0*5/5*6/0*2/1/5*2/0*5/5*6/0*2/1/5*2/1/0*4/5*6/0*2/1/5*2/1/0*4/5*6/0*2/5*3/1/0*4/5*6/0*2/5*4/0*4/5*6/0*2/5*4/0*4/5*6/0*2/5*4/0*4/5*6/0*2/5*4/0*4/5*6/0*2/5*4/0*4/5*6/0*2/5*4/1/0*3/5*6/0/1/5*4/1/0*3/5*6/0*2/5*4/1/0*3/5*6/0/1/5*4/0*4/5*6/0/1/5*4/1/0*3/5*6/0/5*6/0*3/5*6/0/5*6/0*3/5*6/0/5*6/0*3/5*6/0/5*6/0*3/5*6/0/5*6/0*3/5*6/0/5*6/1/0*2/5*6/0/5*6/0*3/5*6/1/5*6/1/0*2/5*6/1/5*6/1/0*2/5*6/1/5*7/0*2/5*14/0*2/5*14/1/0/5*14/1/0/5*14/1*2/5*15/0/5*15/1/5*15/1/5*1264/#63:01:8*21/0/8*10/0/8/0*2/8/0*2/8*3/0/8*2/0/8*3/0*2/8*2/0/8*4/0*2/8*2/0*8/8/0*4/8/0*244/5*825/0/1/2/3/4/5/6/5*2944/#64:01:8*27/0/8*4/0/8*4/0*2/8*2/0/8*2/0*2/8*2/0*3/8*3/0*5/8*2/0/8*2/0*4/8*2/0*3/8/0*5/8/0*240/5*816/7/8/9/10/11/12/13/14/15/5*2951/#65:01:8*17/0/8/0/8/0/8*2/0/8*4/0/8*4/0/8*3/0*3/8*5/0/8/0/8*2/0*3/8/0/8/0/8*3/0*2/8/0*5/8/0*5/8/0*2/8*2/0*240/5*3776/#62:11:8*18/0/8*6/0/8*4/0/8/0/8*2/0/8*7/0*3/8*2/0/8*3/0*2/8*2/0/8/0/8*2/0*2/8*2/0*3/8/0/8/0/8/0*3/8*2/0/8/0*240/5*3776/#";
        //在这里输入存档码
        cout << "已经复制好了(按任意键继续)>>>" << endl;
        string file_end;
        cin >> file_end;
        cout << "正在解析存档信息......" << endl;
        if(readFile(file)){
            //输出解析信息
            cout << "存档包含以下信息：" << endl;
            cout << "1.存档基本信息" << endl;
            cout << "    存档名称：" << filename << endl;
            cout << "    存档保存时间："<< file_savetime << endl;
            cout << "    存档大小："<< getFileSizeUnit(file) << endl;
            cout << "2.玩家与世界基本信息" << endl;
            cout << "    玩家坐标："<< stdpos(playerx,playery) << endl;
            cout << "    玩家名称："<< playername << endl;
            cout << "    世界名称：" << worldname << endl;
            cout << "    世界种子："<< seed << endl;
            cout << "    世界生成海平面："<< sea_level << endl;
            cout << "3.成就与设置信息" << endl;
            cout << "    已获得成就数量："<< getAchievementNum() << "/"<<achievement_num << endl;
            cout << "    成就列表："<< getTrueAchievement() << endl;
            cout << "4.世界信息" << endl;
            cout << "    已加载区块数量："<< world_chunk.size() << endl;
            cout << "获取更详细信息请输入more，否则输入其他字符>>";
            string input_filechoose;
            cin >> input_filechoose;
            if(input_filechoose == "more")
                MoreFile();
            cout << "请确认存档信息是否正确，是输入1,否输入0>>>";
            string input_filechoose2;
            cin >> input_filechoose2;
            if(input_filechoose == "0"){
                cout << "请按照Wiki相关文章检查存档信息，已自动停止运行游戏" << endl;
                return 0;
            }else{
                cout << "存档读入完毕，即将开始游戏" << endl;
                for(int i = 0;i<5;i++){
                    cout << ".";
                    usleep(500000);
                }
                cout << endl;
                usleep(500000);
                clear
                return 1;
            }
        }else{
            cout << "存档无效，重新生成新世界" << endl;
            cout << "世界生成选项" << endl;
            ll option1 = 0,content1 = 0;
            string input1;
            cout << "种子(非0数):";
            cin >> content1;
            if(content1 != 0)
                seed = content1;
            cout << "海平面:";
            content1 = 0;
            cin >> content1;
            if(0 < content1 && content1 < WorldYSize)
                sea_level = content1;
            else
                cout << "不合法的输入,设定为默认值" << sea_level << endl;
        }
        return 1;
    }else{
        cout << "世界生成选项" << endl;
        ll option = 0,content = 0;
        string input;
        cout << "种子(非0数):";
        cin >> content;
        if(content != 0)
            seed = content;
        cout << "海平面:";
        content = 0;
        cin >> content;
        if(0 < content && content < WorldYSize)
            sea_level = content;
        else
            cout << "不合法的输入,设定为默认值" << sea_level << endl;
        return 1;
    }
    clear
    return 1;
}
bool CheckSurvive(){
    if(player_heart > 0)
        return 1;
    else
        return 0;
}//检测玩家是否存活
void FallTest(){
    ll fall_distance = 0;
    while(TestTag(Block_List[world_chunk[gcID(playerx / 16)].GetBlockInfo(playerx,playery + fall_distance)].tag,tag_type[4]))
        fall_distance++;
    if(fall_distance - 3 > 0)
        player_heart -=(fall_distance - 3);
    if(!CheckSurvive()){
        world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery)] = 0;
        PlayerBorn(respawnx,respawny);
        info_text.push(playername + "从高处摔了下来");
    }
}//摔落检测
void UpdatePlayer(){
    if(gamemode != "creative"){
        if(TestTag(tag_type[6],Block_List[world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery)]].tag)){
            info_text.push(language_player[lang] + itos(player_oxygen));
            player_oxygen--;
        }
        else{
            if(player_oxygen < 20)
                player_oxygen += 2;//缓慢恢复，杜绝持续呼吸
        }
        //氧气消耗
        if(player_full > 0)
            player_full -= 0.5;//优先消耗饱食度
        else
            player_hunger -= 0.5;//自然消耗饥饿值
        if(player_hunger <= 0){
            player_hunger = 0;
            player_heart--;
            if(!CheckSurvive()){
                world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery)] = 0;
                PlayerBorn(respawnx,respawny);
                info_text.push(playername + language_kill[lang + 3]);
            }//检测是否被饿死
        }//饥饿值降到零时开始减少生命
        if(player_oxygen <= 0){
            player_oxygen = 0;
            player_heart -= 2;
            if(!CheckSurvive()){
                world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery)] = 0;
                PlayerBorn(respawnx,respawny);
                info_text.push(playername + language_kill[lang + 6]);
            }//检测是否溺水
        }//氧气值降到零时开始以每回合2点减少生命
        if(!TestTag("through",Block_List[world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery)]].tag) && top_block(playerx,ID(block_name,"air")) != -1){
            Transportation((itos(playerx) + " " + itos(top_block(playerx,ID(block_name,"air")))));
        }
        else{
            player_heart -= 20;
            if(!CheckSurvive()){
                world_chunk[gcID(playerx / 16)].terrain[index(topox(playerx),playery)] = 0;
                PlayerBorn(respawnx,respawny);
                info_text.push(playername + "因为奇妙的特性而卡在方块里无法动弹");
            }
        }
    }
}
void UpdateUI(){
    if(active_screen == "main"){
        UpdateScreen();
        BriefInformationPrint();
    }else if(active_screen == "backpack"){
        printBackpack();
        BriefInformationPrint();
    }
    else if(active_screen == "info")//调试信息
        UniversalInformationPrint();
    else{
        active_screen = "main";
        UpdateScreen();
        BriefInformationPrint();
    }//其他界面
}
void surviveMod_init(){
    
}
//主函数
//如何切换至32位系统：
//将#define ll long long这句宏的定义改为#define ll int
//将const ll MAX_INT 的值设为2147483647
//将const ll positive_crash_line的值设为 2147483637
int main(){
    seed = rand();
    bool skip_title = 0;
    nowvisit_UI = &backpack;
    item item_list[128];
    gamemode = "creative";
    Addmod("TestMod","</testmod></test>","<block1,^>","none");//测试模组
    p("欢迎来到Survive游戏，这是社区最大的C++沙盒");
    cout << "语言：中文/中文繁體/English(输入语言名称) >>> ";
    cin >> language;
    if(language == "English")
        lang = 2;
    else if(language == "中文")
        lang = 0;
    else if(language == "中文繁體")
        lang = 1;
    else
        lang = 0;//默认为0
    clear
    cout << language_TitleScreen[lang + 18] << endl;
    cout << "|---------------------------------|"<< endl;
    cout << language_TitleScreen[lang + 15];
    cin >> skip_title;
    clear
    if(!skip_title){
        for(ll i = 0;i<= 6;i++){
            for(ll j = 0;j<= 30;j++){
                cout << TitleScreen[i][j];
                if(j != 30)
                    cout << " ";
            }
            cout << endl;
        }
        cout << language_TitleScreen[lang] << endl;
        cout << language_TitleScreen[lang + 3] << "2021/7/25 16:20:00"<< endl;
        cout << language_TitleScreen[lang + 6] << GameLatestVersion << endl;
        cout << language_TitleScreen[lang + 9] << endl;
        cout << language_TitleScreen[lang + 12] << endl;
        cin >> skip;
        char choose_skip = '1';
        if(!skip){
            clear
            sleep(2);
            p("（附赠小说）");
            p("“欢迎来到这个世界！”");
            p("这是......哪？");
            p("为什么？我明明在肝程序啊......");
            p("等等，这不就是......我自己的游戏世界吗？");
            p("不对，我自己编的游戏，为什么会有我面前这个跟个应急食品一样的人啊！");
            p("“嗨！你醒了啊？前面弄醒你花了不少功夫呢！”");
            p("“你是？”");
            p("“哦对了，我叫Pasy,这个世界的管理员！”");
            p("我赶忙回忆，才想起来自己确实将这东西上传到服务器去运行过。");
            p("但这也解释不通啊......我一个作者到这还能理解，这个我压根见都没见过的“管理员”又是谁啊？！");
            p("“还是比较陌生吧？”");
            p("于是在她的带领下，我被迫听了她对“这个世界”的介绍。");
            p("“我刚刚对这个世界做了调整，原先这个世界只有549,755,813,888个方块，现在有了2,361,183,241,434,822,606,848个方块啦！”");
            p("“停停停停，多少？”");
            p("“二十三垓六千一百一十八京三千二百四十一兆四千三百四十八亿两千两百六十万六千八百四十八个方块啊！”Pasy说道。");
            p("“这可是地球表面积的4,734,114倍，Minecraft总方块数量的2562倍呢！”她还说道。(作者注：Survive可探索世界的大小为2^71个方块，不计负坐标可探索方块)");
            p("天，我自己算都没算过，当初改用64位数据还觉得挺麻烦的......");
            p("“这里64刻为一天，刚刚我们就过去了1刻哦！”");
            p("“刻？我记得自己编的时候一刻等于一个更新回合啊？为什么会有恒定的时间单位？”");
            p("“这里一刻大概多长？”");
            p("“一——二——三——四！这是十六分之一刻啦！”");
            p("一刻等于64个间，一个间是16秒，那么......一天是65536秒......还行。");
            p("（作者注：Survive以64个回合为1天，玩家输入一句指令并使其运行即为一回合，命令组统一算作一回合）");
            p("接着，Pasy“教”了我如何放置破坏方块。");
            p("这个过程里，我见到了此生最难忘的事情——");
            p("她手一指，空中就出现了一个窗口，她在输入了/set d 1 stone后，我面前就出现了一个石头方块。");
            p("然后，输入/break d 1，那个石头就消失了。");
            p("“你也来一下”Pasy手一挥，窗口就移到了我面前。");
            p("作为这个游戏的作者，我决定和她坦白了。");
            p("/gamerule color 1;/gamemode creative;/fill ~-10 ~-10 ~10 ~10 air;/set a 1 barrier;/say I'm the author of the game");
            p("开启颜色，世界便为彩色的；我则变为了创造模式,周围441个方块瞬间被清空，在我左边，出现了一个泛着淡紫色荧光的屏障，那是世界的最后边界；然后，Pasy前面出现了一个小窗口，上面写着“我是游戏创作者”......");
            p("“等等，你是？”Pasy显然十分惊讶。");
            p("“游戏创作者ParseY Pasli.”");
            p("“我也不知道怎么就到了这里，不过，感谢你让我看到了这世界的奇妙，谢谢，不知道从哪来的应急食品。”");
            p("“等等等等”,Pasy突然想起了什么，“我是Pasy，你的......”");
            p("“妹妹啊！哥！”");
            p("此刻又是我觉得不可思议了。");
            p("“我妹妹，不是，一年前，就，失踪了吗？”");
            p("“你是......什么时候......来到这的......”");
            p("“在这个世界481天了......”");
            p("“是你？为什么......”");
            p("“当初不知怎么看到了你的游戏，运行了下，然后就，突然，到了这里。”");
            p("“我用了很长时间才搞懂这个世界的底层，然后，你，就来了......”");
            p("“你找过出去的方法吗？总不可能永远在这个游戏世界里待着吧！”");
            p("“翻了源码，已知唯一可行的方法是使世界崩溃，但我还不知道怎么做......”");
            p("“只要到世界边界就好了！我们现在的坐标是多少？”");
            p("“x = 4611686018427387904, y = 192”");
            p("“当时我做64位改革时设定的坐标，现在看来......”");
            p("“没事，哥哥，我们一起，传送到世界尽头！”");
            p("“我们只要输入/tp ~4611686018427387904 ~就可以了！但......”我突然想起来，“这指令只作用于1个人......");
            p("“我也不知道出去了一个人后会有什么后果......”");
            p("“所以，妹妹，你先出去吧！”");
            p("“不等等，哥！我们说好一起的......一起......”她哭了。");
            p("“走！指令我帮你打好了！”冲上前去，我点了执行。");
            p("“哥！！！”");
            p("“再见了！”我目送着她在虚空中一点点消失，程序在将这个我设定的“意识”传送时，花了不少时间。");
            p("“哥......”");
            p("“其实我当初设定意识实体时，只定义了一个，就是玩家本身，你先来的，所以，我的到来，本身就是违反了世界规则的存在。”");
            p("“那————”");
            p("“结果很显然易见是我被抹除，永远消失，但，妹妹，在你出去后，记住你还有个哥哥......”");
            p("“不要啊......”");
            p("当最后一声呻吟消逝后，Pasy此刻就应该到达了世界边界的超限区域，当她的坐标因为溢出变为-1,192时，程序就会崩溃。");
            p("再见了，我看着显示屏的地形图，世界开始从边界崩塌。");
            p("世界长度慢慢下降到2^48,2^32，2^24......最后，我看向两边无垠的虚空，走向了世界的中央，静候世界完全崩塌的终焉。");
            p("我感受着身体在一阵扰动后，慢慢消失。");
            p("再见了，这个世界。我的意识于是陷入永久的静默。");
            p("房间里，一群人正在讨论。");
            p("“组长，你说过意识实体只能有一个，为什么在他加入时还要临时更改？”");
            p("“在他进入前就已经申请上传意识了，毕竟是游戏的作者，还是得满足他。”");
            p("“还有，能再说说为什么Pasy要进入这个游戏吗？她现在为何又退出了？”");
            p("“一年前当Pasy攻读宇宙学时，她，作为震惊世界的虚无理论的发现者，第一个了解到了世界的本质，一个世界终归会趋于热寂，这样的未来她不肯接受，于是她放弃了现实生活，申请上传自己的意识，来到这个‘永不消失’的数字世界。”");
            p("“但是你也知道，这个游戏是不会开到宇宙尽头的。”");
            p("“她哥哥骗了她，否则她迟早会了结自己的生命，活着已经没有任何意义了，对她来说，如果改变不了宇宙的未来。”");
            p("“她哥哥立马做了失忆手术，忘却这段痛苦的记忆。但是后来学界又修改了虚无理论，宇宙不会热寂，它因为不连续性永远会在稳定与不稳定间徘徊，熵值趋于0，但始终不等于0。”");
            p("“我们立即通知了游戏世界里的她，但是她也出不来了，游戏规则只能从内部打破，当初我们为了世界的稳定设下了层层外部保护，现在却自己解不开那些东西。”");
            p("“她于是与我们一起，寻找游戏世界的漏洞，直到现在，她发现了边界的不稳定性。”");
            p("“我们一直对外宣称她已经失踪了，她本人之前也不想因此被外界所知，于是就连她的家人也不知道，直到最近，她的哥哥，信息学顶峰人物，也发现了信息本身趋于混乱，他也对世界不抱任何希望了”");
            p("“作为游戏作者，他也希望进入这个世界看看，之前因为研究甚至没有亲自看过一眼这个虚拟世界，当那群头号玩家们搞出世界模拟器的时候。”");
            p("“那群玩家对于这个游戏也是挺热爱的，当年在整个社会上引起了轰动呢，毕竟在没有任何外部支持的情况下，他们硬是做出了到现在都无法理解的意识算法！这一个成果就让他们每个人得了无数的奖项。”");
            p("“人们也才认识到原来平日深居简出的肥宅们都能有改变世界的能力。”");
            p("“这么看来，这个世界的创造者也是挺强大的。”");
            p("“岂止是强大！你知道那人干了什么吗？他一个人，重做了量子计算机，效率是现行量子设备的至少2兆倍！这就是当年量子计算与登月设备的差别.....”");
            p("“天才果然是孤独的，当他们已经了解透彻了这个世界后。”");
            p("“她哥哥在进去前又做了一次失忆手术，说是忘却痛苦，游戏世界里发生了什么，我们还不清楚，只不过现在，Pasy的意识已经重新下载到她的躯体里，现在她再睡一会就能醒过来了，至于Pasli，我们还得再启动一次意识转移，那玩意的电费够我们喝一年西北风了......”");
            p("欸？这是......哪？为什么，我不是早已随游戏崩溃了吗......");
            p("“欢迎回来，Pasli！”一个声音说道。");
            p("当我从妹妹口中得知真相的时候，又是震惊。");
            p("“在游戏里时，为什么，要骗我......”");
            p("“他们跟我说了你也要进来，我得装作不知道你，否则你迟早会知道以前的事，到时候你也会承受不住的。”");
            p("“我不能没有你，哥哥。”");
            sleep(1);
            cout << "开始游戏(按任意键继续) -->";
            cin >> choose_skip;
        }
    }
    worldname = "World SU-21903";
    playername = "Pasli";
    if(WorldInit(skip_title) == 0)
        return 0;
    UpdateChunk();
    PlayerBorn(respawnx,respawny);//玩家出生
    UpdateChunk();
    active_screen = "main";
    string command;
    UpdateScreen();//更新屏幕
    BriefInformationPrint();//打印基本信息
    cin.ignore(1);
    while(1){
        game_time++;//游戏时间
        //UpdateBoarder(boarder_x,boarder_y);//更新边境
        UpdatePlayer();//更新玩家信息
        getline(cin,command);//输入
        Command(command);//执行命令
        clear//清屏
        UpdateUI();//更新UI
        UpdateChunk();//更新区块
    }
    return 0;
}
//感谢所有参与或间接帮助的团体，个人等，是你们才让这个游戏直至现在成为社区最大的C++版沙盒游戏。
